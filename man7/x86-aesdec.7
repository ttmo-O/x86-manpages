.nh
.TH "X86-AESDEC" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
AESDEC - PERFORM ONE ROUND OF AN AES DECRYPTION FLOW
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32\-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 38 DE /r AESDEC xmm1, xmm2/m128
T}
	RM	V/V	AES	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128\-bit data (state) from xmm1 with a 128\-bit round key from xmm2/m128.
T}
T{
VEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128
T}
	RVM	V/V	Both AES and AVX flags	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128\-bit data (state) from xmm2 with a 128\-bit round key from xmm3/m128; store the result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand2	Operand3	Operand4
RM	ModRM:reg (r, w)	ModRM:r/m (r)	NA	NA
RVM	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SH DESCRIPTION
.PP
This instruction performs a single round of the AES decryption flow
using the Equivalent Inverse Cipher, with the round key from the second
source operand, operating on a 128\-bit data (state) from the first
source operand, and store the result in the destination operand.

.PP
Use the AESDEC instruction for all but the last decryption round. For
the last decryption round, use the AESDECLAST instruction.

.PP
128\-bit Legacy SSE version: The first source operand and the destination
operand are the same and must be an XMM register. The second source
operand can be an XMM register or a 128\-bit memory location. Bits
(MAXVL\-1:128) of the corresponding YMM destination register remain
unchanged.

.PP
VEX.128 encoded version: The first source operand and the destination
operand are XMM registers. The second source operand can be an XMM
register or a 128\-bit memory location. Bits (MAXVL\-1:128) of the
destination YMM register are zeroed.

.SH OPERATION
.SS AESDEC
.PP
.RS

.nf
STATE ← SRC1;
RoundKey ← SRC2;
STATE ← InvShiftRows( STATE );
STATE ← InvSubBytes( STATE );
STATE ← InvMixColumns( STATE );
DEST[127:0] ← STATE XOR RoundKey;
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SS VAESDEC
.PP
.RS

.nf
STATE ← SRC1;
RoundKey ← SRC2;
STATE ← InvShiftRows( STATE );
STATE ← InvSubBytes( STATE );
STATE ← InvMixColumns( STATE );
DEST[127:0] ← STATE XOR RoundKey;
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
(V)AESDEC: \_\_m128i \_mm\_aesdec (\_\_m128i, \_\_m128i)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
