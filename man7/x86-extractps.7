.nh
.TH "X86-EXTRACTPS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
EXTRACTPS - EXTRACT PACKED FLOATING-POINT VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 3A 17 /r ib EXTRACTPS reg/m32, xmm1, imm8
T}
	A	VV	SSE4\_1	T{
Extract one single\-precision floating\-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64\-bit register if applicable.
T}
T{
VEX.128.66.0F3A.WIG 17 /r ib VEXTRACTPS reg/m32, xmm1, imm8
T}
	A	V/V	AVX	T{
Extract one single\-precision floating\-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64\-bit register if applicable.
T}
T{
EVEX.128.66.0F3A.WIG 17 /r ib VEXTRACTPS reg/m32, xmm1, imm8
T}
	B	V/V	AVX512F	T{
Extract one single\-precision floating\-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64\-bit register if applicable.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	NA	ModRM:r/m (w)	ModRM:reg (r)	Imm8	NA
B	Tuple1 Scalar	ModRM:r/m (w)	ModRM:reg (r)	Imm8	NA
.TE

.SH DESCRIPTION
.PP
Extracts a single\-precision floating\-point value from the source operand
(second operand) at the 32\-bit offset specified from imm8. Immediate
bits higher than the most significant offset for the vector length are
ignored.

.PP
The extracted single\-precision floating\-point value is stored in the low
32\-bits of the destination operand

.PP
In 64\-bit mode, destination register operand has default operand size of
64 bits. The upper 32\-bits of the register are filled with zero. REX.W
is ignored.

.PP
VEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in
64\-bit mode with a general purpose register (GPR) as a destination
operand, the packed single quantity is zero extended to 64 bits.

.PP
VEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions
will #UD.

.PP
128\-bit Legacy SSE version: When a REX.W prefix is used in 64\-bit mode
with a general purpose register (GPR) as a destination operand, the
packed single quantity is zero extended to 64 bits.

.PP
The source register is an XMM register. Imm8[1:0] determine the
starting DWORD offset from which to extract the 32\-bit floating\-point
value.

.PP
If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the
instruction encoded with VEX.L= 1 will cause an #UD exception.

.SH OPERATION
.SS VEXTRACTPS (EVEX and VEX.128 encoded version)
.PP
.RS

.nf
SRC\_OFFSET ← IMM8[1:0]
IF (64\-Bit Mode and DEST is register)
    DEST[31:0]←(SRC[127:0] >> (SRC\_OFFSET*32)) AND 0FFFFFFFFh
    DEST[63:32] ← 0
ELSE
    DEST[31:0]←(SRC[127:0] >> (SRC\_OFFSET*32)) AND 0FFFFFFFFh
FI

.fi
.RE

.SS EXTRACTPS (128\-bit Legacy SSE version)
.PP
.RS

.nf
SRC\_OFFSET ←IMM8[1:0]
IF (64\-Bit Mode and DEST is register)
    DEST[31:0]←(SRC[127:0] >> (SRC\_OFFSET*32)) AND 0FFFFFFFFh
    DEST[63:32] ←0
ELSE
    DEST[31:0]←(SRC[127:0] >> (SRC\_OFFSET*32)) AND 0FFFFFFFFh
FI

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
EXTRACTPS int \_mm\_extract\_ps (\_\_m128 a, const int nidx);

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
VEX\-encoded instructions, see Exceptions Type 5; Additionally

.PP
EVEX\-encoded instructions, see Exceptions Type E9NF.

.TS
allbox;
l l 
l l .
#UD	IF VEX.L = 0.
#UD	T{
If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.
T}
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
