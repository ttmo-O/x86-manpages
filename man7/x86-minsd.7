.nh
.TH "X86-MINSD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
MINSD - RETURN MINIMUM SCALAR DOUBLE-PRECISION FLOATING-POINT VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp / En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
F2 0F 5D /r MINSD xmm1, xmm2/m64
T}
	A	V/V	SSE2	T{
Return the minimum scalar double\-precision floating\-point value between xmm2/m64 and xmm1.
T}
T{
VEX.LIG.F2.0F.WIG 5D /r VMINSD xmm1, xmm2, xmm3/m64
T}
	B	V/V	AVX	T{
Return the minimum scalar double\-precision floating\-point value between xmm3/m64 and xmm2.
T}
T{
EVEX.LIG.F2.0F.W1 5D /r VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}
T}
	C	V/V	AVX512F	T{
Return the minimum scalar double\-precision floating\-point value between xmm3/m64 and xmm2.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	NA	ModRM:reg (r, w)	ModRM:r/m (r)	NA	NA
B	NA	ModRM:reg (w)	VEX.vvvv	ModRM:r/m (r)	NA
C	Tuple1 Scalar	ModRM:reg (w)	EVEX.vvvv	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
Compares the low double\-precision floating\-point values in the first
source operand and the second source operand, and returns the minimum
value to the low quadword of the destination operand. When the source
operand is a memory operand, only the 64 bits are accessed.

.PP
If the values being compared are both 0.0s (of either sign), the value
in the second source operand is returned. If a value in the second
source operand is an SNaN, then SNaN is returned unchanged to the
destination (that is, a QNaN version of the SNaN is not returned).

.PP
If only one value is a NaN (SNaN or QNaN) for this instruction, the
second source operand, either a NaN or a valid floating\-point value, is
written to the result. If instead of this behavior, it is required that
the NaN source operand (from either the first or second source) be
returned, the action of MINSD can be emulated using a sequence of
instructions, such as, a comparison followed by AND, ANDN and OR.

.PP
The second source operand can be an XMM register or a 64\-bit memory
location. The first source and destination operands are XMM registers.

.PP
128\-bit Legacy SSE version: The destination and first source operand are
the same. Bits (MAXVL\-1:64) of the corresponding destination register
remain unchanged.

.PP
VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register
destination are copied from corresponding bits in the first source
operand. Bits (MAXVL\-1:128) of the destination register are zeroed.

.PP
EVEX encoded version: The low quadword element of the destination
operand is updated according to the writemask.

.PP
Software should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD
with VEX.L=1 may encounter unpredictable behavior across different
processor generations.

.SS Operation
.PP
.RS

.nf
MIN(SRC1, SRC2)
{
    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST ←SRC2;
        ELSE IF (SRC1 = SNaN) THEN DEST ←SRC2; FI;
        ELSE IF (SRC2 = SNaN) THEN DEST ←SRC2; FI;
        ELSE IF (SRC1 < SRC2) THEN DEST ←SRC1;
        ELSE DEST←SRC2;
    FI;
}

.fi
.RE

.SS MINSD (EVEX encoded version)
.PP
.RS

.nf
IF k1[0] or *no writemask*
    THEN DEST[63:0]←MIN(SRC1[63:0], SRC2[63:0])
    ELSE
        IF *merging\-masking* ; merging\-masking
            THEN *DEST[63:0] remains unchanged*
            ELSE ; zeroing\-masking
                THEN DEST[63:0]←0
        FI;
FI;
DEST[127:64] ← SRC1[127:64]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS MINSD (VEX.128 encoded version)
.PP
.RS

.nf
DEST[63:0]←MIN(SRC1[63:0], SRC2[63:0])
DEST[127:64] ←SRC1[127:64]
DEST[MAXVL\-1:128] ←0

.fi
.RE

.SS MINSD (128\-bit Legacy SSE version)
.PP
.RS

.nf
DEST[63:0]←MIN(SRC1[63:0], SRC2[63:0])
DEST[MAXVL\-1:64] (Unmodified)

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VMINSD \_\_m128d \_mm\_min\_round\_sd(\_\_m128d a, \_\_m128d b, int);

VMINSD \_\_m128d \_mm\_mask\_min\_round\_sd(\_\_m128d s, \_\_mmask8 k, \_\_m128d a, \_\_m128d b, int);

VMINSD \_\_m128d \_mm\_maskz\_min\_round\_sd( \_\_mmask8 k, \_\_m128d a, \_\_m128d b, int);

MINSD \_\_m128d \_mm\_min\_sd(\_\_m128d a, \_\_m128d b)

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Invalid (including QNaN Source Operand), Denormal

.SS Other Exceptions
.PP
Non\-EVEX\-encoded instruction, see Exceptions Type 3.

.PP
EVEX\-encoded instruction, see Exceptions Type E3.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
