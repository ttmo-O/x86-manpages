.nh
.TH "X86-AESKEYGENASSIST" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
AESKEYGENASSIST - AES ROUND KEY GENERATION ASSIST
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32\-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 3A DF /r ib AESKEYGENASSIST xmm1, xmm2/m128, imm8
T}
	RMI	V/V	AES	T{
Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
T}
T{
VEX.128.66.0F3A.WIG DF /r ib VAESKEYGENASSIST xmm1, xmm2/m128, imm8
T}
	RMI	V/V	Both AES and AVX flags	T{
Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand2	Operand3	Operand4
RMI	ModRM:reg (w)	ModRM:r/m (r)	imm8	NA
.TE

.SH DESCRIPTION
.PP
Assist in expanding the AES cipher key, by computing steps towards
generating a round key for encryption, using 128\-bit data specified in
the source operand and an 8\-bit round constant specified as an
immediate, store the result in the destination operand.

.PP
The destination operand is an XMM register. The source operand can be an
XMM register or a 128\-bit memory location.

.PP
128\-bit Legacy SSE version: Bits (MAXVL\-1:128) of the corresponding YMM
destination register remain unchanged.

.PP
VEX.128 encoded version: Bits (MAXVL\-1:128) of the destination YMM
register are zeroed.

.PP
Note: In VEX\-encoded versions, VEX.vvvv is reserved and must be 1111b,
otherwise instructions will #UD.

.SH OPERATION
.SS AESKEYGENASSIST
.PP
.RS

.nf
X3[31:0] ← SRC [127: 96];
X2[31:0] ← SRC [95: 64];
X1[31:0] ← SRC [63: 32];
X0[31:0] ← SRC [31: 0];
RCON[31:0] ← ZeroExtend(Imm8[7:0]);
DEST[31:0] ← SubWord(X1);
DEST[63:32 ] ← RotWord( SubWord(X1) ) XOR RCON;
DEST[95:64] ← SubWord(X3);
DEST[127:96] ← RotWord( SubWord(X3) ) XOR RCON;
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SS VAESKEYGENASSIST
.PP
.RS

.nf
X3[31:0]←SRC [127: 96];
X2[31:0]←SRC [95: 64];
X1[31:0]←SRC [63: 32];
X0[31:0]←SRC [31: 0];
RCON[31:0] ← ZeroExtend(Imm8[7:0]);
DEST[31:0] ← SubWord(X1);
DEST[63:32 ]←RotWord( SubWord(X1) ) XOR RCON;
DEST[95:64] ← SubWord(X3);
DEST[127:96]←RotWord( SubWord(X3) ) XOR RCON;
DEST[MAXVL\-1:128] ← 0;

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
(V)AESKEYGENASSIST: \_\_m128i \_mm\_aeskeygenassist (\_\_m128i, const int)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4; additionally

.TS
allbox;
l l 
l l .
#UD	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
