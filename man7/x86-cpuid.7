.nh
.TH "X86-CPUID" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
CPUID - CPU IDENTIFICATION
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
0F A2	CPUID	ZO	Valid	Valid	T{
Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
The ID flag (bit 21) in the EFLAGS register indicates support for the
CPUID instruction. If a software procedure can set and clear this flag,
the processor executing the procedure supports the CPUID instruction.
This instruction operates the same in non\-64\-bit modes and 64\-bit mode.

.PP
CPUID returns processor identification and feature information in the
EAX, EBX, ECX, and EDX registers.1 The instruction’s output is dependent
on the contents of the EAX register upon execution (in some cases, ECX
as well). For example, the following pseudocode loads EAX with 00H and
causes CPUID to return a Maximum Return Value and the Vendor
Identification String in the appropriate registers:

.PP
MOV EAX, 00H

.PP
CPUID

.PP
Table 3\-8 shows information returned, depending on the initial value
loaded into the EAX register.

.PP
Two types of information are returned: basic and extended function
information. If a value entered for CPUID.EAX is higher than the maximum
input value for basic or extended function for that processor then the
data for the highest basic information leaf is returned. For example,
using some Intel processors, the following is true:

.PP
CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)

.PP
CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf.
*) CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)2

.PP
.RS

.PP
1\&. On Intel 64 processors, CPUID clears the high 32 bits of the
RAX/RBX/RCX/RDX registers in all modes.

.PP
2\&. CPUID leaf 1FH is a preferred superset to leaf 0BH. Intel
recommends first checking for the existence of CPUID leaf 1FH before
using leaf 0BH.

.RE

.PP
CPUID.EAX = 80000008H (* Returns linear/physical address size data. *)

.PP
CPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX
= 0BH. *)

.PP
If a value entered for CPUID.EAX is less than or equal to the maximum
input value and the leaf is not supported on that processor then 0 is
returned in all the registers.

.PP
When CPUID returns the highest basic leaf information as a result of an
invalid input EAX value, any dependence on input ECX value in the basic
leaf is honored.

.PP
CPUID can be executed at any privilege level to serialize instruction
execution. Serializing instruction execution guarantees that any
modifications to flags, registers, and memory for previous instructions
are completed before the next instruction is fetched and executed.

.PP
See also:

.PP
“Serializing Instructions” in Chapter 8, “Multiple\-Processor
Management,” in the Intel® 64 and IA\-32 Architectures Software
Developer’s Manual, Volume 3A.

.PP
“Caching Translation Information” in Chapter 4, “Paging,” in the Intel®
64 and IA\-32 Architectures Software Developer’s Manual, Volume 3A.

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
Basic CPUID Information

.PP
0H

.PP
EAX Maximum Input Value for Basic CPUID Information. EBX “Genu” ECX
“ntel” EDX “ineI”

.PP
01H

.PP
EAX Version Information: Type, Family, Model, and Stepping ID (see Table
3\-11). NOTES: *
Thenearestpower\-of\-2integerthatisnotsmallerthanEBX[23:16]isthenumberofuniqueinitialAPIC
IDs reserved for addressing different logical processors in a physical
package. This field is only valid if CPUID.1.EDX.HTT[bit 28]= 1. **
The 8\-bit initial APIC ID in EBX[31:24] is replaced by the 32\-bit
x2APIC ID, available in Leaf 0BH and Leaf 1FH.

.PP
02H

.PP
EAX Cache and TLB Information (see Table 3\-12). EBX Cache and TLB
Information. ECX Cache and TLB Information. EDX Cache and TLB
Information.

.PP
03H

.PP
EAX Reserved. EBX Reserved. ECX Bits 00 \- 31 of 96 bit processor serial
number. (Available in Pentium III processor only; otherwise, the value
in this register is reserved.) EDX Bits 32 \- 63 of 96 bit processor
serial number. (Available in Pentium III processor only; otherwise, the
value in this register is reserved.) NOTES: Processor serial number
(PSN) is not supported in the Pentium 4 processor or later. On all
models, use the PSN flag (returned using CPUID) to check for PSN support
before accessing the feature.

.PP
CPUID leaves above 2 and below 80000000H are visible only when
IA32\_MISC\_ENABLE[bit 22] has its default value of 0.

.PP
Deterministic Cache Parameters Leaf

.PP
04H

.PP
NOTES: Leaf 04H output depends on the initial value in ECX.* See also:
“INPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level”
on page 221. EAX Bits 04 \- 00: Cache Type Field. 0 = Null \- No more
caches. 1 = Data Cache. 2 = Instruction Cache. 3 = Unified Cache. 4\-31 =
Reserved.

.PP
Bits 07 \- 05: Cache Level (starts at 1). Bit 08: Self Initializing cache
level (does not need SW initialization). Bit 09: Fully Associative
cache. Bits 13 \- 10: Reserved. Bits 25 \- 14: Maximum number of
addressable IDs for logical processors sharing this cache**, ***\&.
Bits 31 \-\& 26: Maximum number of addressable IDs for processor cores in
the physical package**, ****, *****\&. EBX Bits 11 \-\& 00: L =
System Coherency Line Size**\&. Bits 21 \-\& 12: P = Physical Line
partitions**\&. Bits 31 \-\& 22: W = Ways of associativity**\&. ECX Bits
31\-\&00: S = Number of Sets**\&. EDX Bit 00: Write\-\&Back
Invalidate/Invalidate. 0 = WBINVD/INVD from threads sharing this cache
acts upon lower level caches for threads sharing this cache. 1 =
WBINVD/INVD is not guaranteed to act upon lower level caches of
non\-\&originating threads sharing this cache. Bit 01: Cache Inclusiveness.
0 = Cache is not inclusive of lower cache levels. 1 = Cache is inclusive
of lower cache levels. Bit 02: Complex Cache Indexing. 0 = Direct mapped
cache. 1 = A complex function is used to index the cache, potentially
using all address bits. Bits 31 \-\& 03: Reserved = 0. NOTES: * If ECX
contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0. Sub\-leaf
index n+1 is invalid if sub\-leaf n returns EAX[4:0] as 0. ** Add one
to the return value to get the result. ***The nearest power\-of\-2
integer that is not smaller than (1 + EAX[25:14]) is the number of
unique initial APIC IDs reserved for addressing different logical
processors sharing this cache. **** The nearest power\-of\-2 integer
that is not smaller than (1 + EAX[31:26]) is the number of unique
Core\_IDs reserved for addressing different processor cores in a
physical package. Core ID is a subset of bits of the initial APIC ID.
***** The returned value is constant for valid initial values in
ECX. Valid ECX values start from 0.

.PP
MONITOR/MWAIT Leaf

.PP
05H

.PP
EAX Bits 15 \- 00: Smallest monitor\-line size in bytes (default is
processor's monitor granularity). Bits 31 \- 16: Reserved = 0. EBX Bits
15 \- 00: Largest monitor\-line size in bytes (default is processor's
monitor granularity). Bits 31 \- 16: Reserved = 0. ECX Bit 00:
Enumeration of Monitor\-Mwait extensions (beyond EAX and EBX registers)
supported. Bit 01: Supports treating interrupts as break\-event for
MWAIT, even when interrupts disabled. Bits 31 \- 02: Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
EDX Bits 03 \- 00: Number of C0* sub C\-states supported using MWAIT.
Bits 07 \- 04: Number of C1* sub C\-states supported using MWAIT. Bits 11
\- 08: Number of C2* sub C\-states supported using MWAIT. Bits 15 \- 12:
Number of C3* sub C\-states supported using MWAIT. Bits 19 \- 16: Number
of C4* sub C\-states supported using MWAIT. Bits 23 \- 20: Number of C5*
sub C\-states supported using MWAIT. Bits 27 \- 24: Number of C6* sub
C\-states supported using MWAIT. Bits 31 \- 28: Number of C7* sub
C\-states supported using MWAIT. NOTE: *
ThedefinitionofC0throughC7statesforMWAITextensionareprocessor\-specificC\-states,notACPIC\-states.

.PP
Thermal and Power Management Leaf

.PP
06H

.PP
EAX Bit 00: Digital temperature sensor is supported if set. Bit 01:
Intel Turbo Boost Technology available (see description of
IA32\_MISC\_ENABLE[38]). Bit 02: ARAT. APIC\-Timer\-always\-running
feature is supported if set. Bit 03: Reserved. Bit 04: PLN. Power limit
notification controls are supported if set. Bit 05: ECMD. Clock
modulation duty cycle extension is supported if set. Bit 06: PTM.
Package thermal management is supported if set. Bit 07: HWP. HWP base
registers (IA32\_PM\_ENABLE[bit 0], IA32\_HWP\_CAPABILITIES,
IA32\_HWP\_REQUEST, IA32\_HWP\_STATUS) are supported if set. Bit 08:
HWP\_Notification. IA32\_HWP\_INTERRUPT MSR is supported if set. Bit 09:
HWP\_Activity\_Window. IA32\_HWP\_REQUEST[bits 41:32] is supported if
set. Bit 10: HWP\_Energy\_Performance\_Preference.
IA32\_HWP\_REQUEST[bits 31:24] is supported if set. Bit 11:
HWP\_Package\_Level\_Request. IA32\_HWP\_REQUEST\_PKG MSR is supported
if set. Bit 12: Reserved. Bit 13: HDC. HDC base registers
IA32\_PKG\_HDC\_CTL, IA32\_PM\_CTL1, IA32\_THREAD\_STALL MSRs are
supported if set. Bit 14: Intel® Turbo Boost Max Technology 3.0
available. Bit 15: HWP Capabilities. Highest Performance change is
supported if set. Bit 16: HWP PECI override is supported if set. Bit 17:
Flexible HWP is supported if set. Bit 18: Fast access mode for the
IA32\_HWP\_REQUEST MSR is supported if set. Bit 19: Reserved. Bit 20:
Ignoring Idle Logical Processor HWP request is supported if set. Bits 31
\- 21: Reserved. EBX Bits 03 \- 00: Number of Interrupt Thresholds in
Digital Thermal Sensor. Bits 31 \- 04: Reserved. ECX Bit 00: Hardware
Coordination Feedback Capability (Presence of IA32\_MPERF and
IA32\_APERF). The capability to provide a measure of delivered processor
performance (since last reset of the counters), as a percentage of the
expected processor performance when running at the TSC frequency. Bits
02 \- 01: Reserved = 0. Bit 03: The processor supports performance\-energy
bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
implies the presence of a new architectural MSR called
IA32\_ENERGY\_PERF\_BIAS (1B0H). Bits 31 \- 04: Reserved = 0. EDX
Reserved = 0.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
Structured Extended Feature Flags Enumeration Leaf (Output depends on
ECX input value)

.PP
07H

.PP
Sub\-leaf 0 (Input ECX = 0). * EAX Bits 31 \- 00: Reports the maximum
input value for supported leaf 7 sub\-leaves. EBX Bit 00: FSGSBASE.
Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1. Bit 01:
IA32\_TSC\_ADJUST MSR is supported if 1. Bit 02: SGX. Supports Intel®
Software Guard Extensions (Intel® SGX Extensions) if 1. Bit 03: BMI1.
Bit 04: HLE. Bit 05: AVX2. Bit 06: FDP\_EXCPTN\_ONLY. x87 FPU Data
Pointer updated only on x87 exceptions if 1. Bit 07: SMEP. Supports
Supervisor\-Mode Execution Prevention if 1. Bit 08: BMI2. Bit 09:
Supports Enhanced REP MOVSB/STOSB if 1. Bit 10: INVPCID. If 1, supports
INVPCID instruction for system software that manages process\-context
identifiers. Bit 11: RTM. Bit 12: RDT\-M. Supports Intel® Resource
Director Technology (Intel® RDT) Monitoring capability if 1. Bit 13:
Deprecates FPU CS and FPU DS values if 1. Bit 14: MPX. Supports Intel®
Memory Protection Extensions if 1. Bit 15: RDT\-A. Supports Intel®
Resource Director Technology (Intel® RDT) Allocation capability if 1.
Bit 16: AVX512F. Bit 17: AVX512DQ. Bit 18: RDSEED. Bit 19: ADX. Bit 20:
SMAP. Supports Supervisor\-Mode Access Prevention (and the CLAC/STAC
instructions) if 1. Bit 21: AVX512\_IFMA. Bit 22: Reserved. Bit 23:
CLFLUSHOPT. Bit 24: CLWB. Bit 25: Intel Processor Trace. Bit 26:
AVX512PF. (Intel® Xeon PhiTM only.) Bit 27: AVX512ER. (Intel® Xeon PhiTM
only.) Bit 28: AVX512CD. Bit 29: SHA. supports Intel® Secure Hash
Algorithm Extensions (Intel® SHA Extensions) if 1. Bit 30: AVX512BW. Bit
31: AVX512VL.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
ECX Bit 00: PREFETCHWT1. (Intel® Xeon PhiTM only.) Bit 01: AVX512\_VBMI.
Bit 02: UMIP. Supports user\-mode instruction prevention if 1. Bit 03:
PKU. Supports protection keys for user\-mode pages if 1. Bit 04: OSPKE.
If 1, OS has set CR4.PKE to enable protection keys (and the
RDPKRU/WRPKRU instructions). Bit 05: WAITPKG Bit 07 \- 06: Reserved Bit
08: GFNI Bits 13 \- 09: Reserved. Bit 14: AVX512\_VPOPCNTDQ. (Intel® Xeon
PhiTM only.) Bits 16 \- 15: Reserved. Bits 21 \- 17: The value of MAWAU
used by the BNDLDX and BNDSTX instructions in 64\-bit mode. Bit 22: RDPID
and IA32\_TSC\_AUX are available if 1. Bits 24 \- 23: Reserved. Bit 25:
CLDEMOTE. Supports cache line demote if 1. Bit 26: Reserved Bit 27:
MOVDIRI. Supports MOVDIRI if 1. Bit 28: MOVDIR64B. Supports MOVDIR64B if
1. Bit 29: Reserved Bit 30: SGX\_LC. Supports SGX Launch Configuration
if 1. Bit 31: Reserved. EDX Bit 01: Reserved. Bit 02: AVX512\_4VNNIW.
(Intel® Xeon PhiTM only.) Bit 03: AVX512\_4FMAPS. (Intel® Xeon PhiTM
only.) Bits 25\-04: Reserved. Bit 26: Enumerates support for indirect
branch restricted speculation (IBRS) and the indirect branch predictor
barrier (IBPB). Processors that set this bit support the
IA32\_SPEC\_CTRL MSR and the IA32\_PRED\_CMD MSR. They allow software to
set IA32\_SPEC\_CTRL[0] (IBRS) and IA32\_PRED\_CMD[0] (IBPB). Bit
27: Enumerates support for single thread indirect branch predictors
(STIBP). Processors that set this bit support the IA32\_SPEC\_CTRL MSR.
They allow software to set IA32\_SPEC\_CTRL[1] (STIBP). Bit 28:
Enumerates support for L1D\_FLUSH. Processors that set this bit support
the IA32\_FLUSH\_CMD MSR. They allow software to set
IA32\_FLUSH\_CMD[0] (L1D\_FLUSH). Bit 29: Enumerates support for the
IA32\_ARCH\_CAPABILITIES MSR. Bit 30: Enumerates support for the
IA32\_CORE\_CAPABILITIES MSR. Bit 31: Enumerates support for Speculative
Store Bypass Disable (SSBD). Processors that set this bit support the
IA32\_SPEC\_CTRL MSR. They allow software to set IA32\_SPEC\_CTRL[2]
(SSBD). NOTE: * If ECX contains an invalid sub\-leaf index,
EAX/EBX/ECX/EDX return 0. Sub\-leaf index n is invalid if n exceeds the
value that sub\-leaf 0 returns in EAX.

.PP
Direct Cache Access Information Leaf

.PP
09H

.PP
EAX Value of bits [31:0] of IA32\_PLATFORM\_DCA\_CAP MSR (address
1F8H). EBX Reserved. ECX Reserved. EDX Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
Architectural Performance Monitoring Leaf

.PP
0AH

.PP
EAX Bits 07 \- 00: Version ID of architectural performance monitoring.
Bits 15 \- 08: Number of general\-purpose performance monitoring counter
per logical processor. Bits 23 \- 16: Bit width of general\-purpose,
performance monitoring counter. Bits 31 \- 24: Length of EBX bit vector
to enumerate architectural performance monitoring events. EBX Bit 00:
Core cycle event not available if 1. Bit 01: Instruction retired event
not available if 1. Bit 02: Reference cycles event not available if 1.
Bit 03: Last\-level cache reference event not available if 1. Bit 04:
Last\-level cache misses event not available if 1. Bit 05: Branch
instruction retired event not available if 1. Bit 06: Branch mispredict
retired event not available if 1. Bits 31 \- 07: Reserved = 0. ECX
Reserved = 0. EDX Bits 04 \- 00: Number of fixed\-function performance
counters (if Version ID \&gt; 1). Bits 12 \- 05: Bit width of
fixed\-function performance counters (if Version ID \&gt; 1). Bits 14 \-
13: Reserved = 0. Bit 15: AnyThread deprecation. Bits 31 \- 16: Reserved
= 0.

.PP
Extended Topology Enumeration Leaf

.PP
0BH

.PP
NOTES: * Software should use this field (EAX[4:0]) to enumerate
processor topology of the system.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
** Software must not use EBX[15:0] to enumerate processor topology
of the system. This value in this field (EBX[15:0]) is only intended
for display/diagnostic purposes. The actual number of logical processors
available to BIOS/OS/Applications may be different from the value of
EBX[15:0], depending on software and platform hardware configurations.
*** The value of the “level type” field is not related to level
numbers in any way, higher “level type” values do not mean higher
levels. Level type field has the following encoding: 0: Invalid. 1: SMT.
2: Core. 3\-255: Reserved.

.PP
Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)

.PP
0DH

.PP
NOTES: Leaf 0DH main leaf (ECX = 0). EAX Bits 31 \- 00: Reports the
supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1
only if EAX[n] is 1. Bit 00: x87 state. Bit 01: SSE state. Bit 02: AVX
state. Bits 04 \- 03: MPX state. Bits 07 \- 05: AVX\-512 state. Bit 08:
Used for IA32\_XSS. Bit 09: PKRU state. Bits 12 \- 10: Reserved. Bit 13:
Used for IA32\_XSS. Bits 31 \- 14: Reserved. EBX Bits 31 \- 00: Maximum
size (bytes, from the beginning of the XSAVE/XRSTOR save area) required
by enabled features in XCR0. May be different than ECX if some features
at the end of the XSAVE save area are not enabled. ECX Bit 31 \- 00:
Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area)
of the XSAVE/XRSTOR save area required by all supported features in the
processor, i.e., all the valid bit fields in XCR0. EDX Bit 31 \- 00:
Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32]
can be set to 1 only if EDX[n] is 1. Bits 31 \- 00: Reserved.

.PP
Processor Extended State Enumeration Sub\-leaf (EAX = 0DH, ECX = 1)

.PP
0DH

.PP
EAX Bit 00: XSAVEOPT is available. Bit 01: Supports XSAVEC and the
compacted form of XRSTOR if set. Bit 02: Supports XGETBV with ECX = 1 if
set. Bit 03: Supports XSAVES/XRSTORS and IA32\_XSS if set. Bits 31 \- 04:
Reserved. EBX Bits 31 \- 00: The size in bytes of the XSAVE area
containing all states enabled by XCRO | IA32\_XSS. ECX Bits 31 \- 00:
Reports the supported bits of the lower 32 bits of the IA32\_XSS MSR.
IA32\_XSS[n] can be set to 1 only if ECX[n] is 1. Bits 07 \- 00: Used
for XCR0. Bit 08: PT state. Bit 09: Used for XCR0. Bits 12 \- 10:
Reserved. Bit 13: HWP state. Bits 31 \- 14: Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
EDX Bits 31 \- 00: Reports the supported bits of the upper 32 bits of the
IA32\_XSS MSR. IA32\_XSS[n+32] can be set to 1 only if EDX[n] is 1.
Bits 31 \- 00: Reserved.

.PP
Processor Extended State Enumeration Sub\-leaves (EAX = 0DH, ECX = n, n
\&gt; 1)

.PP
0DH

.PP
NOTES: Leaf 0DH output depends on the initial value in ECX. Each
sub\-leaf index (starting at position 2) is supported if it corresponds
to a supported bit in either the XCR0 register or the IA32\_XSS MSR. *
If ECX contains an invalid sub\-leaf index, EAX/EBX/ECX/EDX return 0.
Sub\-leaf n (0 ≤ n ≤ 31) is invalid if sub\-leaf 0 returns 0 in EAX[n]
and sub\-leaf 1 returns 0 in ECX[n]\&. Sub\-\&leaf n (32 ≤ n ≤ 63) is
invalid if sub\-\&leaf 0 returns 0 in EDX[n\-32] and sub\-leaf 1 returns 0
in EDX[n\-32]\&. EAX Bits 31 \-\& 0: The size in bytes (from the offset
specified in EBX) of the save area for an extended state feature
associated with a valid sub\-\&leaf index, n, is invalid*; otherwise it is
reserved.

.PP
Intel Resource Director Technology (Intel RDT) Monitoring Enumeration
Sub\-leaf (EAX = 0FH, ECX = 0)

.PP
0FH

.PP
NOTES: Leaf 0FH output depends on the initial value in ECX. Sub\-leaf
index 0 reports valid resource type starting at bit position 1 of EDX.
EAX Reserved. EBX Bits 31 \- 00: Maximum range (zero\-based) of RMID
within this physical processor of all types. ECX Reserved. EDX Bit 00:
Reserved. Bit 01: Supports L3 Cache Intel RDT Monitoring if 1. Bits 31 \-
02: Reserved.

.PP
L3 Cache Intel RDT Monitoring Capability Enumeration Sub\-leaf (EAX =
0FH, ECX = 1)

.PP
0FH

.PP
NOTES: Leaf 0FH output depends on the initial value in ECX. EAX
Reserved. EBX Bits 31 \- 00: Conversion factor from reported
IA32\_QM\_CTR value to occupancy metric (bytes) and Memory Bandwidth
Monitoring (MBM) metrics. ECX Maximum range (zero\-based) of RMID of this
resource type. EDX Bit 00: Supports L3 occupancy monitoring if 1. Bit
01: Supports L3 Total Bandwidth monitoring if 1. Bit 02: Supports L3
Local Bandwidth monitoring if 1. Bits 31 \- 03: Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
Intel Resource Director Technology (Intel RDT) Allocation Enumeration
Sub\-leaf (EAX = 10H, ECX = 0)

.PP
10H

.PP
NOTES: Leaf 10H output depends on the initial value in ECX. Sub\-leaf
index 0 reports valid resource identification (ResID) starting at bit
position 1 of EBX. EAX Reserved. EBX Bit 00: Reserved. Bit 01: Supports
L3 Cache Allocation Technology if 1. Bit 02: Supports L2 Cache
Allocation Technology if 1. Bit 03: Supports Memory Bandwidth Allocation
if 1. Bits 31 \- 04: Reserved. ECX Reserved. EDX Reserved.

.PP
L3 Cache Allocation Technology Enumeration Sub\-leaf (EAX = 10H, ECX =
ResID =1)

.PP
10H

.PP
NOTES: Leaf 10H output depends on the initial value in ECX. EAX Bits 04
\- 00: Length of the capacity bit mask for the corresponding ResID using
minus\-one notation. Bits 31 \- 05: Reserved. EBX Bits 31 \- 00:
Bit\-granular map of isolation/contention of allocation units. ECX Bits
01\- 00: Reserved. Bit 02: Code and Data Prioritization Technology
supported if 1. Bits 31 \- 03: Reserved. EDX Bits 15 \- 00: Highest COS
number supported for this ResID. Bits 31 \- 16: Reserved.

.PP
L2 Cache Allocation Technology Enumeration Sub\-leaf (EAX = 10H, ECX =
ResID =2)

.PP
10H

.PP
NOTES: Leaf 10H output depends on the initial value in ECX. EAX Bits 04
\- 00: Length of the capacity bit mask for the corresponding ResID using
minus\-one notation. Bits 31 \- 05: Reserved. EBX Bits 31 \- 00:
Bit\-granular map of isolation/contention of allocation units. ECX Bits
31 \- 00: Reserved. EDX Bits 15 \- 00: Highest COS number supported for
this ResID. Bits 31 \- 16: Reserved.

.PP
Memory Bandwidth Allocation Enumeration Sub\-leaf (EAX = 10H, ECX = ResID
=3)

.PP
10H

.PP
NOTES: Leaf 10H output depends on the initial value in ECX. EAX Bits 11
\- 00: Reports the maximum MBA throttling value supported for the
corresponding ResID using minus\-one notation. Bits 31 \- 12: Reserved.
EBX Bits 31 \- 00: Reserved. ECX Bits 01 \- 00: Reserved. Bit 02: Reports
whether the response of the delay values is linear. Bits 31 \- 03:
Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
EDX Bits 15 \- 00: Highest COS number supported for this ResID. Bits 31 \-
16: Reserved.

.PP
Intel SGX Capability Enumeration Leaf, sub\-leaf 0 (EAX = 12H, ECX = 0)

.PP
12H

.PP
NOTES: Leaf 12H sub\-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H,
ECX=0H):EBX[SGX] = 1. EAX Bit 00: SGX1. If 1, Indicates Intel SGX
supports the collection of SGX1 leaf functions. Bit 01: SGX2. If 1,
Indicates Intel SGX supports the collection of SGX2 leaf functions. Bits
04 \- 02: Reserved. Bit 05: If 1, indicates Intel SGX supports ENCLV
instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT. Bit
06: If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC,
ERDINFO, ELDBC, and ELDUC. Bits 31 \- 07: Reserved. EBX Bits 31 \- 00:
MISCSELECT. Bit vector of supported extended SGX features. ECX Bits 31 \-
00: Reserved. EDX Bits 07 \- 00: MaxEnclaveSize\_Not64. The maximum
supported enclave size in non\-64\-bit mode is 2^(EDX[7:0]). Bits 15 \-
08: MaxEnclaveSize\_64. The maximum supported enclave size in 64\-bit
mode is 2^(EDX[15:8]). Bits 31 \- 16: Reserved.

.PP
Intel SGX Attributes Enumeration Leaf, sub\-leaf 1 (EAX = 12H, ECX = 1)

.PP
12H

.PP
NOTES: Leaf 12H sub\-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H,
ECX=0H):EBX[SGX] = 1. EAX Bit 31 \- 00: Reports the valid bits of
SECS.ATTRIBUTES[31:0] that software can set with ECREATE. EBX Bit 31 \-
00: Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can
set with ECREATE. ECX Bit 31 \- 00: Reports the valid bits of
SECS.ATTRIBUTES[95:64] that software can set with ECREATE. EDX Bit 31
\- 00: Reports the valid bits of SECS.ATTRIBUTES[127:96] that software
can set with ECREATE.

.PP
Intel SGX EPC Enumeration Leaf, sub\-leaves (EAX = 12H, ECX = 2 or
higher)

.PP
12H

.PP
NOTES: Leaf 12H sub\-leaf 2 or higher (ECX \&gt;= 2) is supported if
CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. For sub\-leaves (ECX = 2 or
higher), definition of EDX,ECX,EBX,EAX[31:4] depends on the sub\-leaf
type listed below. EAX Bit 03 \- 00: Sub\-leaf Type 0000b: Indicates this
sub\-leaf is invalid. 0001b: This sub\-leaf enumerates an EPC section.
EBX:EAX and EDX:ECX provide information on the Enclave Page Cache (EPC)
section. All other type encodings are reserved. Type 0000b. This
sub\-leaf is invalid. EDX:ECX:EBX:EAX return 0.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
Type 0001b. This sub\-leaf enumerates an EPC sections with EDX:ECX,
EBX:EAX defined as follows. EAX[11:04]: Reserved (enumerate 0).
EAX[31:12]: Bits 31:12 of the physical address of the base of the EPC
section. EBX[19:00]: Bits 51:32 of the physical address of the base of
the EPC section. EBX[31:20]: Reserved. ECX[03:00]: EPC section
property encoding defined as follows: If EAX[3:0] 0000b, then all bits
of the EDX:ECX pair are enumerated as 0. If EAX[3:0] 0001b, then this
section has confidentiality and integrity protection. All other
encodings are reserved. ECX[11:04]: Reserved (enumerate 0).
ECX[31:12]: Bits 31:12 of the size of the corresponding EPC section
within the Processor Reserved Memory. EDX[19:00]: Bits 51:32 of the
size of the corresponding EPC section within the Processor Reserved
Memory. EDX[31:20]: Reserved.

.PP
Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)

.PP
14H

.PP
NOTES: Leaf 14H main leaf (ECX = 0). EAX Bits 31 \- 00: Reports the
maximum sub\-leaf supported in leaf 14H. EBX Bit 00: If 1, indicates that
IA32\_RTIT\_CTL.CR3Filter can be set to 1, and that
IA32\_RTIT\_CR3\_MATCH MSR can be accessed. Bit 01: If 1, indicates
support of Configurable PSB and Cycle\-Accurate Mode. Bit 02: If 1,
indicates support of IP Filtering, TraceStop filtering, and preservation
of Intel PT MSRs across warm reset. Bit 03: If 1, indicates support of
MTC timing packet and suppression of COFI\-based packets. Bit 04: If 1,
indicates support of PTWRITE. Writes can set IA32\_RTIT\_CTL[12]
(PTWEn) and IA32\_RTIT\_CTL[5] (FUPonPTW), and PTWRITE can generate
packets. Bit 05: If 1, indicates support of Power Event Trace. Writes
can set IA32\_RTIT\_CTL[4] (PwrEvtEn), enabling Power Event Trace
packet generation. Bit 31 \- 06: Reserved. ECX Bit 00: If 1, Tracing can
be enabled with IA32\_RTIT\_CTL.ToPA = 1, hence utilizing the ToPA
output scheme; IA32\_RTIT\_OUTPUT\_BASE and
IA32\_RTIT\_OUTPUT\_MASK\_PTRS MSRs can be accessed. Bit 01: If 1, ToPA
tables can hold any number of output entries, up to the maximum allowed
by the MaskOrTableOffset field of IA32\_RTIT\_OUTPUT\_MASK\_PTRS. Bit
02: If 1, indicates support of Single\-Range Output scheme. Bit 03: If 1,
indicates support of output to Trace Transport subsystem. Bit 30 \- 04:
Reserved. Bit 31: If 1, generated packets which contain IP payloads have
LIP values, which include the CS base component. EDX Bits 31 \- 00:
Reserved.

.PP
Intel Processor Trace Enumeration Sub\-leaf (EAX = 14H, ECX = 1)

.PP
14H

.PP
EAX Bits 02 \- 00: Number of configurable Address Ranges for filtering.
Bits 15 \- 03: Reserved. Bits 31 \- 16: Bitmap of supported MTC period
encodings. EBX Bits 15 \- 00: Bitmap of supported Cycle Threshold value
encodings. Bit 31 \- 16: Bitmap of supported Configurable PSB frequency
encodings. ECX Bits 31 \- 00: Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
EDX Bits 31 \- 00: Reserved.

.PP
Time Stamp Counter and Nominal Core Crystal Clock Information Leaf

.PP
15H

.PP
NOTES: If EBX[31:0] is 0, the TSC/”core crystal clock” ratio is not
enumerated. EBX[31:0]/EAX[31:0] indicates the ratio of the TSC
frequency and the core crystal clock frequency. If ECX is 0, the nominal
core crystal clock frequency is not enumerated. “TSC frequency” = “core
crystal clock frequency” * EBX/EAX. The core crystal clock may differ
from the reference clock, bus clock, or core clock frequencies. EAX Bits
31 \- 00: An unsigned integer which is the denominator of the TSC/”core
crystal clock” ratio. EBX Bits 31 \- 00: An unsigned integer which is the
numerator of the TSC/”core crystal clock” ratio. ECX Bits 31 \- 00: An
unsigned integer which is the nominal frequency of the core crystal
clock in Hz. EDX Bits 31 \- 00: Reserved = 0.

.PP
Processor Frequency Information Leaf

.PP
16H

.PP
EAX Bits 15 \- 00: Processor Base Frequency (in MHz). Bits 31 \- 16:
Reserved =0. EBX Bits 15 \- 00: Maximum Frequency (in MHz). Bits 31 \- 16:
Reserved = 0. ECX Bits 15 \- 00: Bus (Reference) Frequency (in MHz). Bits
31 \- 16: Reserved = 0. EDX Reserved. NOTES: * Data is returned from
this interface in accordance with the processor's specification and does
not reflect actual values. Suitable use of this data includes the
display of processor information in like manner to the processor brand
string and for determining the appropriate range to use when displaying
processor information e.g. frequency history graphs. The returned
information should not be used for any other purpose as the returned
information does not accurately correlate to information / counters
returned by other processor interfaces. While a processor may support
the Processor Frequency Information leaf, fields that return a value of
zero are not supported.

.PP
System\-On\-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX =
0)

.PP
17H

.PP
NOTES: Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the
initial value in ECX. Leaf 17H sub\-leaves 1 through 3 reports SOC Vendor
Brand String. Leaf 17H is valid if MaxSOCID\_Index \&gt;= 3. Leaf 17H
sub\-leaves 4 and above are reserved. EAX Bits 31 \- 00: MaxSOCID\_Index.
Reports the maximum input value of supported sub\-leaf in leaf 17H. EBX
Bits 15 \- 00: SOC Vendor ID. Bit 16: IsVendorScheme. If 1, the SOC
Vendor ID field is assigned via an industry standard enumeration scheme.
Otherwise, the SOC Vendor ID field is assigned by Intel. Bits 31 \- 17:
Reserved = 0. ECX Bits 31 \- 00: Project ID. A unique number an SOC
vendor assigns to its SOC projects. EDX Bits 31 \- 00: Stepping ID. A
unique number within an SOC project that an SOC vendor assigns.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
System\-On\-Chip Vendor Attribute Enumeration Sub\-leaf (EAX = 17H, ECX =
1..3)

.PP
17H

.PP
EAX Bit 31 \- 00: SOC Vendor Brand String. UTF\-8 encoded string. EBX Bit
31 \- 00: SOC Vendor Brand String. UTF\-8 encoded string. ECX Bit 31 \- 00:
SOC Vendor Brand String. UTF\-8 encoded string. EDX Bit 31 \- 00: SOC
Vendor Brand String. UTF\-8 encoded string. NOTES: Leaf 17H output
depends on the initial value in ECX. SOC Vendor Brand String is a UTF\-8
encoded string padded with trailing bytes of 00H. The complete SOC
Vendor Brand String is constructed by concatenating in ascending order
of EAX:EBX:ECX:EDX and from the sub\-leaf 1 fragment towards sub\-leaf 3.

.PP
System\-On\-Chip Vendor Attribute Enumeration Sub\-leaves (EAX = 17H, ECX
\&gt; MaxSOCID\_Index)

.PP
17H

.PP
NOTES: Leaf 17H output depends on the initial value in ECX. EAX Bits 31
\- 00: Reserved = 0. EBX Bits 31 \- 00: Reserved = 0. ECX Bits 31 \- 00:
Reserved = 0. EDX Bits 31 \- 00: Reserved = 0.

.PP
Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX =
0)

.PP
18H

.PP
NOTES: Each sub\-leaf enumerates a different address translation
structure. If ECX contains an invalid sub\-leaf index, EAX/EBX/ECX/EDX
return 0. Sub\-leaf index n is invalid if n exceeds the value that
sub\-leaf 0 returns in EAX. A sub\-leaf index is also invalid if
EDX[4:0] returns 0. Valid sub\-leaves do not need to be contiguous or
in any particular order. A valid sub\-leaf may be in a higher input ECX
value than an invalid sub\-leaf or than a valid sub\-leaf of a higher or
lower\-level structure. * Some unified TLBs will allow a single TLB
entry to satisfy data read/write and instruction fetches. Others will
require separate entries (e.g., one loaded on data read/write and
another loaded on an instruction fetch) . Please see the Intel® 64 and
IA\-32 Architectures Optimization Reference Manual for details of a
particular product. ** Add one to the return value to get the result.
EAX Bits 31 \- 00: Reports the maximum input value of supported sub\-leaf
in leaf 18H. EBX Bit 00: 4K page size entries supported by this
structure. Bit 01: 2MB page size entries supported by this structure.
Bit 02: 4MB page size entries supported by this structure. Bit 03: 1 GB
page size entries supported by this structure. Bits 07 \- 04: Reserved.
Bits 10 \- 08: Partitioning (0: Soft partitioning between the logical
processors sharing this structure). Bits 15 \- 11: Reserved. Bits 31 \-
16: W = Ways of associativity. ECX Bits 31 \- 00: S = Number of Sets.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
EDX Bits 04 \- 00: Translation cache type field. 00000b: Null (indicates
this sub\-leaf is not valid). 00001b: Data TLB. 00010b: Instruction TLB.
00011b: Unified TLB*\&. All other encodings are reserved. Bits 07 \-\& 05:
Translation cache level (starts at 1). Bit 08: Fully associative
structure. Bits 13 \-\& 09: Reserved. Bits 25\-\& 14: Maximum number of
addressable IDs for logical processors sharing this translation
cache** Bits 31 \- 26: Reserved.

.PP
Deterministic Address Translation Parameters Sub\-leaf (EAX = 18H, ECX ≥
1)

.PP
18H

.PP
NOTES: Each sub\-leaf enumerates a different address translation
structure. If ECX contains an invalid sub\-leaf index, EAX/EBX/ECX/EDX
return 0. Sub\-leaf index n is invalid if n exceeds the value that
sub\-leaf 0 returns in EAX. A sub\-leaf index is also invalid if
EDX[4:0] returns 0. Valid sub\-leaves do not need to be contiguous or
in any particular order. A valid sub\-leaf may be in a higher input ECX
value than an invalid sub\-leaf or than a valid sub\-leaf of a higher or
lower\-level structure. * Some unified TLBs will allow a single TLB
entry to satisfy data read/write and instruction fetches. Others will
require separate entries (e.g., one loaded on data read/write and
another loaded on an instruction fetch) . Please see the Intel® 64 and
IA\-32 Architectures Optimization Reference Manual for details of a
particular product. ** Add one to the return value to get the result.
EAX Bits 31 \- 00: Reserved. EBX Bit 00: 4K page size entries supported
by this structure. Bit 01: 2MB page size entries supported by this
structure. Bit 02: 4MB page size entries supported by this structure.
Bit 03: 1 GB page size entries supported by this structure. Bits 07 \-
04: Reserved. Bits 10 \- 08: Partitioning (0: Soft partitioning between
the logical processors sharing this structure). Bits 15 \- 11: Reserved.
Bits 31 \- 16: W = Ways of associativity. ECX Bits 31 \- 00: S = Number of
Sets. EDX Bits 04 \- 00: Translation cache type field. 0000b: Null
(indicates this sub\-leaf is not valid). 0001b: Data TLB. 0010b:
Instruction TLB. 0011b: Unified TLB*\&. All other encodings are reserved.
Bits 07 \-\& 05: Translation cache level (starts at 1). Bit 08: Fully
associative structure. Bits 13 \-\& 09: Reserved. Bits 25\-\& 14: Maximum
number of addressable IDs for logical processors sharing this
translation cache** Bits 31 \- 26: Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.PP
Initial EAX Value

.PP
Information Provided about the Processor

.PP
V2 Extended Topology Enumeration Leaf

.PP
1FH

.PP
NOTES: * Software should use this field (EAX[4:0]) to enumerate
processor topology of the system. ** Software must not use EBX[15:0]
to enumerate processor topology of the system. This value in this field
(EBX[15:0]) is only intended for display/diagnostic purposes. The
actual number of logical processors available to BIOS/OS/Applications
may be different from the value of EBX[15:0], depending on software
and platform hardware configurations. *** The value of the “level
type” field is not related to level numbers in any way, higher “level
type” values do not mean higher levels. Level type field has the
following encoding: 0: Invalid. 1: SMT. 2: Core. 3: Module. 4: Tile. 5:
Die. 6\-255: Reserved.

.PP
Unimplemented CPUID Leaf Functions

.PP
40000000H \-4FFFFFFFH

.PP
Invalid. No existing or future CPU will return processor identification
or feature information if the initial EAX value is in the range
40000000H to 4FFFFFFFH.

.PP
Extended Function CPUID Information

.PP
80000000H

.PP
EAX Maximum Input Value for Extended Function CPUID Information. EBX
Reserved. ECX Reserved.

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.TS
allbox;
l l 
l l .
\fB\fCInitial EAX Value\fR	\fB\fCT{
Information Provided about the Processor
T}
\fR
	EDX Reserved.
80000001H	T{
EAX Extended Processor Signature and Feature Bits. EBX Reserved. ECX Bit 00: LAHF/SAHF available in 64\-bit mode.
T}
*
T{
 Bits 04 \- 01: Reserved. Bit 05: LZCNT. Bits 07 \- 06: Reserved. Bit 08: PREFETCHW. Bits 31 \- 09: Reserved. EDX Bits 10 \- 00: Reserved. Bit 11: SYSCALL/SYSRET.
T}
*

*
T{
 Bits 19 \- 12: Reserved = 0. Bit 20: Execute Disable Bit available. Bits 25 \- 21: Reserved = 0. Bit 26: 1\-GByte pages are available if 1. Bit 27: RDTSCP and IA32
T}
\_
TSC
\_
T{
AUX are available if 1. Bit 28: Reserved = 0. Bit 29: Intel® 64 Architecture available if 1. Bits 31 \- 30: Reserved = 0. NOTES: 
T}
*
T{
 LAHFandSAHFarealwaysavailableinothermodes,regardlessoftheenumerationofthisfeatureflag. 
T}
*

*
T{
 Intel processors support SYSCALL and SYSRET only in 64\-bit mode. This feature flag is always enumerated as 0 outside 64\-bit mode.
T}
80000002H	T{
EAX Processor Brand String. EBX Processor Brand String Continued. ECX Processor Brand String Continued. EDX Processor Brand String Continued.
T}
80000003H	T{
EAX Processor Brand String Continued. EBX Processor Brand String Continued. ECX Processor Brand String Continued. EDX Processor Brand String Continued.
T}
80000004H	T{
EAX Processor Brand String Continued. EBX Processor Brand String Continued. ECX Processor Brand String Continued. EDX Processor Brand String Continued.
T}
80000005H	T{
EAX Reserved = 0. EBX Reserved = 0. ECX Reserved = 0. EDX Reserved = 0.
T}
80000006H	T{
EAX Reserved = 0. EBX Reserved = 0. ECX Bits 07 \- 00: Cache Line size in bytes. Bits 11 \- 08: Reserved. Bits 15 \- 12: L2 Associativity field 
T}
*
T{
\&. Bits 31 \-\& 16: Cache size in 1K units. EDX Reserved = 0.
T}
.TE

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.TS
allbox;
l l 
l l .
\fB\fCInitial EAX Value\fR	\fB\fCT{
Information Provided about the Processor
T}
\fR
	NOTES: 
*
T{
 L2 associativity field encodings: 00H \- Disabled 08H \- 16 ways 01H \- 1 way (direct mapped) 09H \- Reserved 02H \- 2 ways 0AH \- 32 ways 03H \- Reserved 0BH \- 48 ways 04H \- 4 ways 0CH \- 64 ways 05H \- Reserved 0DH \- 96 ways 06H \- 8 ways 0EH \- 128 ways 07H \- See CPUID leaf 04H, sub\-leaf 2
T}
*

*
 0FH \- Fully associative 
*

*
T{
 CPUID leaf 04H provides details of deterministic cache parameters, including the L2 cache in sub\-leaf 2
T}
80000007H	T{
EAX Reserved = 0. EBX Reserved = 0. ECX Reserved = 0. EDX Bits 07 \- 00: Reserved = 0. Bit 08: Invariant TSC available if 1. Bits 31 \- 09: Reserved = 0.
T}
80000008H	T{
EAX Linear/Physical Address size. Bits 07 \- 00: 
T}
#
Physical Address Bits
*
\&. Bits 15 \-\& 08: 
#
T{
Linear Address Bits. Bits 31 \- 16: Reserved = 0. EBX Reserved = 0. ECX Reserved = 0. EDX Reserved = 0. NOTES: 
T}
*
 IfCPUID.80000008H:EAX
[
7:0
]
T{
issupported,themaximumphysicaladdressnumbersupportedshould come from this field.
T}
.TE

.PP
Table 3\-8. Information Returned by CPUID Instruction (Contd.)

.SH INPUT EAX = 0: RETURNS CPUID’S HIGHEST VALUE FOR BASIC PROCESSOR INFORMATION AND THE VENDOR IDENTIFICATION STRING
.PP
When CPUID executes with EAX set to 0, the processor returns the highest
value the CPUID recognizes for returning basic processor information.
The value is returned in the EAX register and is processor specific.

.PP
A vendor identification string is also returned in EBX, EDX, and ECX.
For Intel processors, the string is “GenuineIntel” and is expressed:

.PP
EBX ← 756e6547h (* “Genu”, with G in the low eight bits of BL *) EDX ←
49656e69h (* “ineI”, with i in the low eight bits of DL *) ECX ←
6c65746eh (* “ntel”, with n in the low eight bits of CL *)

.SH INPUT EAX = 80000000H: RETURNS CPUID’S HIGHEST VALUE FOR EXTENDED PROCESSOR INFORMATION
.PP
When CPUID executes with EAX set to 80000000H, the processor returns the
highest value the processor recognizes for returning extended processor
information. The value is returned in the EAX register and is processor
specific.

.SH IA32\_BIOS\_SIGN\_ID RETURNS MICROCODE UPDATE SIGNATURE
.PP
For processors that support the microcode update facility, the
IA32\_BIOS\_SIGN\_ID MSR is loaded with the update signature whenever
CPUID executes. The signature is returned in the upper DWORD. For
details, see Chapter 9 in the Intel® 64 and IA\-32 Architectures Software
Developer’s Manual, Volume 3A.

.SH INPUT EAX = 01H: RETURNS MODEL, FAMILY, STEPPING INFORMATION
.PP
When CPUID executes with EAX set to 01H, version information is returned
in EAX (see Figure 3\-6). For example: model, family, and processor type
for the Intel Xeon processor 5100 series is as follows:

.RS
.IP \(bu 2
Model — 1111B
.IP \(bu 2
Family — 0101B
.IP \(bu 2
Processor Type — 00B

.RE

.PP
See Table 3\-9 for available processor type values. Stepping IDs are
provided as needed.

.PP
31 28272019 1615141312118 74
30SteppingExtendedExtendedFamilyModelEAXIDFamily IDModel IDIDExtended
Family ID (0)Extended Model ID (0)Processor TypeFamily (0FH for the
Pentium 4 Processor Family)ModelReserved

.PP
Figure 3\-6. Version Information Returned by CPUID in EAX

.TS
allbox;
l l 
l l .
\fB\fCType\fR	\fB\fCEncoding\fR
Original OEM Processor	00B
Intel OverDrive® Processor	01B
T{
Dual processor (not applicable to Intel486 processors)
T}
	10B
Intel reserved	11B
.TE

.PP
Table 3\-9. Processor Type Field

.PP
.RS

.PP
See Chapter 19 in the Intel® 64 and IA\-32 Architectures Software
Developer’s Manual, Volume 1, for information on identifying earlier
IA\-32 processors.

.RE

.PP
The Extended Family ID needs to be examined only when the Family ID is
0FH. Integrate the fields into a display using the following rule:

.PP
IF Family\_ID ≠ 0FH THEN DisplayFamily = Family\_ID;

.PP
ELSE DisplayFamily = Extended\_Family\_ID + Family\_ID;

.PP
(* Right justify and zero\-extend 4\-bit field. *)

.PP
FI;

.PP
(* Show DisplayFamily as HEX field. *)

.PP
The Extended Model ID needs to be examined only when the Family ID is
06H or 0FH. Integrate the field into a display using the following rule:

.PP
IF (Family\_ID = 06H or Family\_ID = 0FH)

.PP
THEN DisplayModel = (Extended\_Model\_ID « 4) + Model\_ID;

.PP
(* Right justify and zero\-extend 4\-bit field; display Model\_ID as HEX
field.*)

.PP
ELSE DisplayModel = Model\_ID;

.PP
FI;

.PP
(* Show DisplayModel as HEX field. *)

.SH INPUT EAX = 01H: RETURNS ADDITIONAL INFORMATION IN EBX
.PP
When CPUID executes with EAX set to 01H, additional information is
returned to the EBX register:

.RS
.IP \(bu 2
Brand index (low byte of EBX) — this number provides an entry into a
brand string table that contains brand strings for IA\-32 processors.
More information about this field is provided later in this section.
.IP \(bu 2
CLFLUSH instruction cache line size (second byte of EBX) — this
number indicates the size of the cache line flushed by the CLFLUSH
and CLFLUSHOPT instructions in 8\-byte increments. This field was
introduced in the Pentium 4 processor.
.IP \(bu 2
Local APIC ID (high byte of EBX) — this number is the 8\-bit ID that
is assigned to the local APIC on the processor during power up. This
field was introduced in the Pentium 4 processor.

.RE

.SH INPUT EAX = 01H: RETURNS FEATURE INFORMATION IN ECX AND EDX
.PP
When CPUID executes with EAX set to 01H, feature information is returned
in ECX and EDX.

.RS
.IP \(bu 2
Table 3\-10 show encodings for ECX.
.IP \(bu 2
Table 3\-11 show encodings for EDX.

.RE

.PP
For all feature flags, a 1 indicates that the feature is supported. Use
Intel to properly interpret feature flags.

.PP
.RS

.PP
Software must confirm that a processor feature is present using
feature flags returned by CPUID prior to using the feature. Software
should not depend on future offerings retaining all features.

.RE

.TS
allbox;
l 
l .
T{
31302928272625242322212019181716151413121110 9 8 7 6 5 4 3 2 1 0 ECX 0 RDRAND F16C AVX OSXSAVE XSAVE AES TSC\-Deadline POPCNT MOVBE x2APIC SSE4
T}
\_
2 — SSE4.2 SSE4
\_
T{
1 — SSE4.1 DCA — Direct Cache Access PCID — Process\-context Identifiers PDCM — Perf/Debug Capability MSR xTPR Update Control CMPXCHG16B FMA — Fused Multiply Add SDBG CNXT\-ID — L1 Context ID SSSE3 — SSSE3 Extensions TM2 — Thermal Monitor 2 EIST — Enhanced Intel SpeedStep® Technology SMX — Safer Mode Extensions VMX — Virtual Machine Extensions DS\-CPL — CPL Qualified Debug Store MONITOR — MONITOR/MWAIT DTES64 — 64\-bit DS Area PCLMULQDQ — Carryless Multiplication SSE3 — SSE3 Extensions OM16524b Reserved
T}
.TE

.PP
Figure 3\-7. Feature Information Returned in the ECX Register

.TS
allbox;
l l l l 
l l l l .
	Bit #	Mnemonic	Description
	0	SSE3	T{
Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.
T}
1	PCLMULQDQ	T{
PCLMULQDQ. A value of 1 indicates the processor supports the PCLMULQDQ instruction.
T}
	2	DTES64	T{
64\-bit DS Area. A value of 1 indicates the processor supports DS area using 64\-bit layout.
T}
	3	MONITOR	T{
MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.
T}
	4	DS\-CPL	T{
CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.
T}
	5	VMX	T{
Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.
T}
	6	SMX	T{
Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See Chapter 6, “Safer Mode Extensions Reference”.
T}
	7	EIST	T{
Enhanced Intel SpeedStep® technology. A value of 1 indicates that the processor supports this technology.
T}
	8	TM2	T{
Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.
T}
	9	SSSE3	T{
A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0 indicates the instruction extensions are not present in the processor.
T}
	10	CNXT\-ID	T{
L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32
T}
\_MISC\_T{
ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.
T}
	11	SDBG	T{
A value of 1 indicates the processor supports IA32
T}
\_DEBUG\_T{
INTERFACE MSR for silicon debug.
T}
	12	FMA	T{
A value of 1 indicates the processor supports FMA extensions using YMM state.
T}
	13	CMPXCHG16B	T{
CMPXCHG16B Available. A value of 1 indicates that the feature is available. See the “CMPXCHG8B/CMPXCHG16B—Compare and Exchange Bytes” section in this chapter for a description.
T}
	14	xTPR Update Control	T{
xTPR Update Control. A value of 1 indicates that the processor supports changing IA32
T}
\_MISC\_ENABLE[bit 23]\&.	15	PDCM	T{
Perfmon and Debug Capability: A value of 1 indicates the processor supports the performance and debug feature indication MSR IA32
T}
\_PERF\_CAPABILITIES.	16	Reserved	Reserved	17	PCID	T{
Process\-context identifiers. A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
T}
	18	DCA	T{
A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device.
T}
	19	SSE4.1	T{
A value of 1 indicates that the processor supports SSE4.1.
T}
	20	SSE4.2	T{
A value of 1 indicates that the processor supports SSE4.2.
T}
	21	x2APIC	T{
A value of 1 indicates that the processor supports x2APIC feature.
T}
	22	MOVBE	T{
A value of 1 indicates that the processor supports MOVBE instruction.
T}
	23	POPCNT	T{
A value of 1 indicates that the processor supports the POPCNT instruction.
T}
	24	TSC\-Deadline	T{
A value of 1 indicates that the processor’s local APIC timer supports one\-shot operation using a TSC deadline value.
T}
	25	AESNI	T{
A value of 1 indicates that the processor supports the AESNI instruction extensions.
T}
	26	XSAVE	T{
A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the XSETBV/XGETBV instructions, and XCR0.
T}
	27	OSXSAVE	T{
A value of 1 indicates that the OS has set CR4.OSXSAVE
T}
[bit 18]T{
 to enable XSETBV/XGETBV instructions to access XCR0 and to support processor extended state management using XSAVE/XRSTOR.
T}
	28	AVX	T{
A value of 1 indicates the processor supports the AVX instruction extensions.
T}
	29	F16C	T{
A value of 1 indicates that processor supports 16\-bit floating\-point conversion instructions.
T}
	30	RDRAND	T{
A value of 1 indicates that processor supports RDRAND instruction.
T}
	31	Not Used	Always returns 0.	.TE

.PP
Table 3\-10. Feature Information Returned in the ECX Register

.PP
EDXPBE–Pend. Brk. EN.TM–Therm. MonitorHTT–Multi\-threadingSS–Self
SnoopSSE2–SSE2 ExtensionsSSE–SSE ExtensionsFXSR–FXSAVE/FXRSTORMMX–MMX
TechnologyACPI–Thermal Monitor and Clock CtrlDS–Debug StoreCLFSH–CLFLUSH
instructionPSN–Processor Serial NumberPSE\-36 – Page Size
ExtensionPAT–Page Attribute TableCMOV–Conditional Move/Compare
InstructionMCA–Machine Check ArchitecturePGE–PTE Global BitMTRR–Memory
Type Range RegistersSEP–SYSENTER and SYSEXITAPIC–APIC on
ChipCX8–CMPXCHG8B Inst.MCE–Machine Check ExceptionPAE–Physical Address
ExtensionsMSR–RDMSR and WRMSR SupportTSC–Time Stamp CounterPSE–Page Size
ExtensionsDE–Debugging ExtensionsVME–Virtual\-8086 Mode
EnhancementFPU–x87 FPU on ChipReserved

.PP
Figure 3\-8. Feature Information Returned in the EDX Register

.TS
allbox;
l l l 
l l l .
\fB\fCBit #\fR	\fB\fCMnemonic\fR	\fB\fCDescription\fR
0	FPU	T{
Floating Point Unit On\-Chip. The processor contains an x87 FPU.
T}
1	VME	T{
Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.
T}
2	DE	T{
Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.
T}
3	PSE	T{
Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
T}
4	TSC	T{
Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
T}
5	MSR	T{
Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
T}
6	PAE	T{
Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2\-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
T}
7	MCE	T{
Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model\-specific implementations of machine\-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.
T}
8	CX8	T{
CMPXCHG8B Instruction. The compare\-and\-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
T}
9	APIC	T{
APIC On\-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default \- some processors permit the APIC to be relocated).
T}
10	Reserved	Reserved
11	SEP	T{
SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported.
T}
12	MTRR	T{
Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.
T}
13	PGE	T{
Page Global Bit. The global bit is supported in paging\-structure entries that map a page, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.
T}
14	MCA	T{
Machine Check Architecture. A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG
T}
\_
T{
CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.
T}
15	CMOV	T{
Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
T}
16	PAT	T{
Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
T}
17	PSE\-36	T{
36\-Bit Page Size Extension. 4\-MByte pages addressing physical memory beyond 4 GBytes are supported with 32\-bit paging. This feature indicates that upper bits of the physical address of a 4\-MByte page are encoded in bits 20:13 of the page\-directory entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
T}
18	PSN	T{
Processor Serial Number. The processor supports the 96\-bit processor identification number feature and the feature is enabled.
T}
19	CLFSH	T{
CLFLUSH Instruction. CLFLUSH Instruction is supported.
T}
20	Reserved	Reserved
21	DS	T{
Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and processor event\-based sampling (PEBS) facilities (see Chapter 23, “Introduction to Virtual\-Machine Extensions,” in the Intel® 64 and IA\-32 Architectures Software Developer’s Manual, Volume 3C).
T}
22	ACPI	T{
Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.
T}
23	MMX	T{
Intel MMX Technology. The processor supports the Intel MMX technology.
T}
24	FXSR	T{
FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.
T}
25	SSE	T{
SSE. The processor supports the SSE extensions.
T}
26	SSE2	T{
SSE2. The processor supports the SSE2 extensions.
T}
27	SS	T{
Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.
T}
28	HTT	T{
Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in the package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX
T}
[
23:16
]
T{
 (the Maximum number of addressable IDs for logical processors in this package) is valid for the package.
T}
29	TM	T{
Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).
T}
30	Reserved	Reserved
31	PBE	T{
Pending Break Enable. The processor supports the use of the FERR
T}
#
/PBE
#
T{
 pin when the processor is in the stop\-clock state (STPCLK
T}
#
T{
 is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32
T}
\_
MISC
\_
T{
ENABLE MSR enables this capability.
T}
.TE

.PP
Table 3\-11. More on Feature Information Returned in the EDX Register

.SH INPUT EAX = 02H: TLB/CACHE/PREFETCH INFORMATION RETURNED IN EAX, EBX, ECX, EDX
.PP
When CPUID executes with EAX set to 02H, the processor returns
information about the processor’s internal TLBs, cache and prefetch
hardware in the EAX, EBX, ECX, and EDX registers. The information is
reported in encoded form and fall into the following categories:

.RS
.IP \(bu 2
The least\-significant byte in register EAX (register AL) will always
return 01H. Software should ignore this value and not interpret it
as an informational descriptor.
.IP \(bu 2
The most significant bit (bit 31) of each register indicates whether
the register contains valid information (set to 0) or is reserved
(set to 1).
.IP \(bu 2
If a register contains valid information, the information is
contained in 1 byte descriptors. There are four types of encoding
values for the byte descriptor, the encoding type is noted in the
second column of Table 3\-12. Table 3\-12 lists the encoding of these
descriptors. Note that the order of descriptors in the EAX, EBX,
ECX, and EDX registers is not defined; that is, specific bytes are
not designated to contain descriptors for specific cache, prefetch,
or TLB types. The descriptors may appear in any order. Note also a
processor may report a general descriptor type (FFH) and not report
any byte descriptor of “cache type” via CPUID leaf 2.

.RE

.TS
allbox;
l l l 
l l l .
\fB\fCValue\fR	\fB\fCType\fR	\fB\fCDescription\fR
00H	General	T{
Null descriptor, this byte contains no information
T}
01H	TLB	T{
Instruction TLB: 4 KByte pages, 4\-way set associative, 32 entries
T}
02H	TLB	T{
Instruction TLB: 4 MByte pages, fully associative, 2 entries
T}
03H	TLB	T{
Data TLB: 4 KByte pages, 4\-way set associative, 64 entries
T}
04H	TLB	T{
Data TLB: 4 MByte pages, 4\-way set associative, 8 entries
T}
05H	TLB	T{
Data TLB1: 4 MByte pages, 4\-way set associative, 32 entries
T}
06H	Cache	T{
1st\-level instruction cache: 8 KBytes, 4\-way set associative, 32 byte line size
T}
08H	Cache	T{
1st\-level instruction cache: 16 KBytes, 4\-way set associative, 32 byte line size
T}
09H	Cache	T{
1st\-level instruction cache: 32KBytes, 4\-way set associative, 64 byte line size
T}
0AH	Cache	T{
1st\-level data cache: 8 KBytes, 2\-way set associative, 32 byte line size
T}
0BH	TLB	T{
Instruction TLB: 4 MByte pages, 4\-way set associative, 4 entries
T}
0CH	Cache	T{
1st\-level data cache: 16 KBytes, 4\-way set associative, 32 byte line size
T}
0DH	Cache	T{
1st\-level data cache: 16 KBytes, 4\-way set associative, 64 byte line size
T}
0EH	Cache	T{
1st\-level data cache: 24 KBytes, 6\-way set associative, 64 byte line size
T}
1DH	Cache	T{
2nd\-level cache: 128 KBytes, 2\-way set associative, 64 byte line size
T}
21H	Cache	T{
2nd\-level cache: 256 KBytes, 8\-way set associative, 64 byte line size
T}
22H	Cache	T{
3rd\-level cache: 512 KBytes, 4\-way set associative, 64 byte line size, 2 lines per sector
T}
23H	Cache	T{
3rd\-level cache: 1 MBytes, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
24H	Cache	T{
2nd\-level cache: 1 MBytes, 16\-way set associative, 64 byte line size
T}
25H	Cache	T{
3rd\-level cache: 2 MBytes, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
29H	Cache	T{
3rd\-level cache: 4 MBytes, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
2CH	Cache	T{
1st\-level data cache: 32 KBytes, 8\-way set associative, 64 byte line size
T}
30H	Cache	T{
1st\-level instruction cache: 32 KBytes, 8\-way set associative, 64 byte line size
T}
40H	Cache	T{
No 2nd\-level cache or, if processor contains a valid 2nd\-level cache, no 3rd\-level cache
T}
41H	Cache	T{
2nd\-level cache: 128 KBytes, 4\-way set associative, 32 byte line size
T}
42H	Cache	T{
2nd\-level cache: 256 KBytes, 4\-way set associative, 32 byte line size
T}
43H	Cache	T{
2nd\-level cache: 512 KBytes, 4\-way set associative, 32 byte line size
T}
44H	Cache	T{
2nd\-level cache: 1 MByte, 4\-way set associative, 32 byte line size
T}
45H	Cache	T{
2nd\-level cache: 2 MByte, 4\-way set associative, 32 byte line size
T}
46H	Cache	T{
3rd\-level cache: 4 MByte, 4\-way set associative, 64 byte line size
T}
47H	Cache	T{
3rd\-level cache: 8 MByte, 8\-way set associative, 64 byte line size
T}
48H	Cache	T{
2nd\-level cache: 3MByte, 12\-way set associative, 64 byte line size
T}
49H	Cache	T{
3rd\-level cache: 4MB, 16\-way set associative, 64\-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H); 2nd\-level cache: 4 MByte, 16\-way set associative, 64 byte line size
T}
4AH	Cache	T{
3rd\-level cache: 6MByte, 12\-way set associative, 64 byte line size
T}
4BH	Cache	T{
3rd\-level cache: 8MByte, 16\-way set associative, 64 byte line size
T}
4CH	Cache	T{
3rd\-level cache: 12MByte, 12\-way set associative, 64 byte line size
T}
4DH	Cache	T{
3rd\-level cache: 16MByte, 16\-way set associative, 64 byte line size
T}
4EH	Cache	T{
2nd\-level cache: 6MByte, 24\-way set associative, 64 byte line size
T}
4FH	TLB	T{
Instruction TLB: 4 KByte pages, 32 entries
T}
50H	TLB	T{
Instruction TLB: 4 KByte and 2\-MByte or 4\-MByte pages, 64 entries
T}
51H	TLB	T{
Instruction TLB: 4 KByte and 2\-MByte or 4\-MByte pages, 128 entries
T}
52H	TLB	T{
Instruction TLB: 4 KByte and 2\-MByte or 4\-MByte pages, 256 entries
T}
55H	TLB	T{
Instruction TLB: 2\-MByte or 4\-MByte pages, fully associative, 7 entries
T}
56H	TLB	T{
Data TLB0: 4 MByte pages, 4\-way set associative, 16 entries
T}
57H	TLB	T{
Data TLB0: 4 KByte pages, 4\-way associative, 16 entries
T}
59H	TLB	T{
Data TLB0: 4 KByte pages, fully associative, 16 entries
T}
5AH	TLB	T{
Data TLB0: 2 MByte or 4 MByte pages, 4\-way set associative, 32 entries
T}
5BH	TLB	T{
Data TLB: 4 KByte and 4 MByte pages, 64 entries
T}
5CH	TLB	T{
Data TLB: 4 KByte and 4 MByte pages,128 entries
T}
5DH	TLB	T{
Data TLB: 4 KByte and 4 MByte pages,256 entries
T}
60H	Cache	T{
1st\-level data cache: 16 KByte, 8\-way set associative, 64 byte line size
T}
61H	TLB	T{
Instruction TLB: 4 KByte pages, fully associative, 48 entries
T}
63H	TLB	T{
Data TLB: 2 MByte or 4 MByte pages, 4\-way set associative, 32 entries and a separate array with 1 GByte pages, 4\-way set associative, 4 entries
T}
64H	TLB	T{
Data TLB: 4 KByte pages, 4\-way set associative, 512 entries
T}
66H	Cache	T{
1st\-level data cache: 8 KByte, 4\-way set associative, 64 byte line size
T}
67H	Cache	T{
1st\-level data cache: 16 KByte, 4\-way set associative, 64 byte line size
T}
68H	Cache	T{
1st\-level data cache: 32 KByte, 4\-way set associative, 64 byte line size
T}
6AH	Cache	T{
uTLB: 4 KByte pages, 8\-way set associative, 64 entries
T}
6BH	Cache	T{
DTLB: 4 KByte pages, 8\-way set associative, 256 entries
T}
6CH	Cache	T{
DTLB: 2M/4M pages, 8\-way set associative, 128 entries
T}
6DH	Cache	T{
DTLB: 1 GByte pages, fully associative, 16 entries
T}
70H	Cache	T{
Trace cache: 12 K\-μop, 8\-way set associative
T}
71H	Cache	T{
Trace cache: 16 K\-μop, 8\-way set associative
T}
72H	Cache	T{
Trace cache: 32 K\-μop, 8\-way set associative
T}
76H	TLB	T{
Instruction TLB: 2M/4M pages, fully associative, 8 entries
T}
78H	Cache	T{
2nd\-level cache: 1 MByte, 4\-way set associative, 64byte line size
T}
79H	Cache	T{
2nd\-level cache: 128 KByte, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
7AH	Cache	T{
2nd\-level cache: 256 KByte, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
7BH	Cache	T{
2nd\-level cache: 512 KByte, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
7CH	Cache	T{
2nd\-level cache: 1 MByte, 8\-way set associative, 64 byte line size, 2 lines per sector
T}
7DH	Cache	T{
2nd\-level cache: 2 MByte, 8\-way set associative, 64byte line size
T}
7FH	Cache	T{
2nd\-level cache: 512 KByte, 2\-way set associative, 64\-byte line size
T}
80H	Cache	T{
2nd\-level cache: 512 KByte, 8\-way set associative, 64\-byte line size
T}
82H	Cache	T{
2nd\-level cache: 256 KByte, 8\-way set associative, 32 byte line size
T}
83H	Cache	T{
2nd\-level cache: 512 KByte, 8\-way set associative, 32 byte line size
T}
84H	Cache	T{
2nd\-level cache: 1 MByte, 8\-way set associative, 32 byte line size
T}
85H	Cache	T{
2nd\-level cache: 2 MByte, 8\-way set associative, 32 byte line size
T}
86H	Cache	T{
2nd\-level cache: 512 KByte, 4\-way set associative, 64 byte line size
T}
87H	Cache	T{
2nd\-level cache: 1 MByte, 8\-way set associative, 64 byte line size
T}
.TE

.PP
Table 3\-12. Encoding of CPUID Leaf 2 Descriptors

.TS
allbox;
l l l 
l l l .
Value	Type	Description
A0H	DTLB	T{
DTLB: 4k pages, fully associative, 32 entries
T}
B0H	TLB	T{
Instruction TLB: 4 KByte pages, 4\-way set associative, 128 entries
T}
B1H	TLB	T{
Instruction TLB: 2M pages, 4\-way, 8 entries or 4M pages, 4\-way, 4 entries
T}
B2H	TLB	T{
Instruction TLB: 4KByte pages, 4\-way set associative, 64 entries
T}
B3H	TLB	T{
Data TLB: 4 KByte pages, 4\-way set associative, 128 entries
T}
B4H	TLB	T{
Data TLB1: 4 KByte pages, 4\-way associative, 256 entries
T}
B5H	TLB	T{
Instruction TLB: 4KByte pages, 8\-way set associative, 64 entries
T}
B6H	TLB	T{
Instruction TLB: 4KByte pages, 8\-way set associative, 128 entries
T}
BAH	TLB	T{
Data TLB1: 4 KByte pages, 4\-way associative, 64 entries
T}
C0H	TLB	T{
Data TLB: 4 KByte and 4 MByte pages, 4\-way associative, 8 entries
T}
C1H	STLB	T{
Shared 2nd\-Level TLB: 4 KByte/2MByte pages, 8\-way associative, 1024 entries
T}
C2H	DTLB	T{
DTLB: 4 KByte/2 MByte pages, 4\-way associative, 16 entries
T}
C3H	STLB	T{
Shared 2nd\-Level TLB: 4 KByte /2 MByte pages, 6\-way associative, 1536 entries. Also 1GBbyte pages, 4\-way, 16 entries.
T}
C4H	DTLB	T{
DTLB: 2M/4M Byte pages, 4\-way associative, 32 entries
T}
CAH	STLB	T{
Shared 2nd\-Level TLB: 4 KByte pages, 4\-way associative, 512 entries
T}
D0H	Cache	T{
3rd\-level cache: 512 KByte, 4\-way set associative, 64 byte line size
T}
D1H	Cache	T{
3rd\-level cache: 1 MByte, 4\-way set associative, 64 byte line size
T}
D2H	Cache	T{
3rd\-level cache: 2 MByte, 4\-way set associative, 64 byte line size
T}
D6H	Cache	T{
3rd\-level cache: 1 MByte, 8\-way set associative, 64 byte line size
T}
D7H	Cache	T{
3rd\-level cache: 2 MByte, 8\-way set associative, 64 byte line size
T}
D8H	Cache	T{
3rd\-level cache: 4 MByte, 8\-way set associative, 64 byte line size
T}
DCH	Cache	T{
3rd\-level cache: 1.5 MByte, 12\-way set associative, 64 byte line size
T}
DDH	Cache	T{
3rd\-level cache: 3 MByte, 12\-way set associative, 64 byte line size
T}
DEH	Cache	T{
3rd\-level cache: 6 MByte, 12\-way set associative, 64 byte line size
T}
E2H	Cache	T{
3rd\-level cache: 2 MByte, 16\-way set associative, 64 byte line size
T}
E3H	Cache	T{
3rd\-level cache: 4 MByte, 16\-way set associative, 64 byte line size
T}
E4H	Cache	T{
3rd\-level cache: 8 MByte, 16\-way set associative, 64 byte line size
T}
EAH	Cache	T{
3rd\-level cache: 12MByte, 24\-way set associative, 64 byte line size
T}
EBH	Cache	T{
3rd\-level cache: 18MByte, 24\-way set associative, 64 byte line size
T}
ECH	Cache	T{
3rd\-level cache: 24MByte, 24\-way set associative, 64 byte line size
T}
F0H	Prefetch	64\-Byte prefetching
F1H	Prefetch	128\-Byte prefetching
FEH	General	T{
CPUID leaf 2 does not report TLB descriptor information; use CPUID leaf 18H to query TLB and other address translation parameters.
T}
FFH	General	T{
CPUID leaf 2 does not report cache descriptor information, use CPUID leaf 4 to query cache parameters
T}
.TE

.PP
Table 3\-12. Encoding of CPUID Leaf 2 Descriptors (Contd.)

.SH EXAMPLE 3\-1. EXAMPLE OF CACHE AND TLB INTERPRETATION
.PP
The first member of the family of Pentium 4 processors returns the
following information about caches and TLBs when the CPUID executes with
an input value of 2:

.PP
EAX 66 5B 50 01H EBX 0H ECX 0H EDX 00 7A 70 00H

.PP
Which means:

.RS
.IP \(bu 2
The least\-significant byte (byte 0) of register EAX is set to 01H.
This value should be ignored.
.IP \(bu 2
The most\-significant bit of all four registers (EAX, EBX, ECX, and
EDX) is set to 0, indicating that each register contains valid
1\-byte descriptors.
.IP \(bu 2
Bytes 1, 2, and 3 of register EAX indicate that the processor has:
.RS
.IP \(bu 2
50H \- a 64\-entry instruction TLB, for mapping 4\-KByte and
2\-MByte or 4\-MByte pages.
.IP \(bu 2
50H \- a 64\-entry instruction TLB, for mapping 4\-KByte and
2\-MByte or 4\-MByte pages.
.IP \(bu 2
5BH \- a 64\-entry data TLB, for mapping 4\-KByte and 4\-MByte
pages.
.IP \(bu 2
5BH \- a 64\-entry data TLB, for mapping 4\-KByte and 4\-MByte
pages.
.IP \(bu 2
66H \- an 8\-KByte 1st level data cache, 4\-way set associative,
with a 64\-Byte cache line size.
.IP \(bu 2
66H \- an 8\-KByte 1st level data cache, 4\-way set associative,
with a 64\-Byte cache line size.

.RE

.IP \(bu 2
The descriptors in registers EBX and ECX are valid, but contain NULL
descriptors.
.IP \(bu 2
Bytes 0, 1, 2, and 3 of register EDX indicate that the processor
has:
.RS
.IP \(bu 2
00H \- NULL descriptor.
.IP \(bu 2
00H \- NULL descriptor.
.IP \(bu 2
70H \- Trace cache: 12 K\-μop, 8\-way set associative.
.IP \(bu 2
70H \- Trace cache: 12 K\-μop, 8\-way set associative.
.IP \(bu 2
7AH \- a 256\-KByte 2nd level cache, 8\-way set associative, with a
sectored, 64\-byte cache line size.
.IP \(bu 2
7AH \- a 256\-KByte 2nd level cache, 8\-way set associative, with a
sectored, 64\-byte cache line size.
.IP \(bu 2
00H \- NULL descriptor.
.IP \(bu 2
00H \- NULL descriptor.

.RE


.RE

.SH INPUT EAX = 04H: RETURNS DETERMINISTIC CACHE PARAMETERS FOR EACH LEVEL
.PP
When CPUID executes with EAX set to 04H and ECX contains an index value,
the processor returns encoded data that describe a set of deterministic
cache parameters (for the cache level associated with the input in ECX).
Valid index values start from 0.

.PP
Software can enumerate the deterministic cache parameters for each level
of the cache hierarchy starting with an index value of 0, until the
parameters report the value associated with the cache type field is 0.
The architecturally defined fields reported by deterministic cache
parameters are documented in Table 3\-8.

.PP
This Cache Size in Bytes

.PP
= (Ways + 1) * (Partitions + 1) * (Line\_Size + 1) * (Sets + 1)

.PP
= (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX
+ 1)

.PP
The CPUID leaf 04H also reports data that can be used to derive the
topology of processor cores in a physical package. This information is
constant for all valid index values. Software can query the raw data
reported by executing CPUID with EAX=04H and ECX=0 and use it as part of
the topology enumeration algorithm described in Chapter 8,
“Multiple\-Processor Management,” in the Intel® 64 and IA\-32
Architectures Software Developer’s Manual, Volume 3A.

.SH INPUT EAX = 05H: RETURNS MONITOR AND MWAIT FEATURES
.PP
When CPUID executes with EAX set to 05H, the processor returns
information about features available to MONITOR/MWAIT instructions. The
MONITOR instruction is used for address\-range monitoring in conjunction
with MWAIT instruction. The MWAIT instruction optionally provides
additional extensions for advanced power management. See Table 3\-8.

.SH INPUT EAX = 06H: RETURNS THERMAL AND POWER MANAGEMENT FEATURES
.PP
When CPUID executes with EAX set to 06H, the processor returns
information about thermal and power management features. See Table 3\-8.

.SH INPUT EAX = 07H: RETURNS STRUCTURED EXTENDED FEATURE ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 07H and ECX = 0, the processor
returns information about the maximum input value for sub\-leaves that
contain extended feature flags. See Table 3\-8.

.PP
When CPUID executes with EAX set to 07H and the input value of ECX is
invalid (see leaf 07H entry in Table 3\-8), the processor returns 0 in
EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of
the highest leaf 7 sub\-leaf, and EBX, ECX \& EDX contain information of
extended feature flags.

.SH INPUT EAX = 09H: RETURNS DIRECT CACHE ACCESS INFORMATION
.PP
When CPUID executes with EAX set to 09H, the processor returns
information about Direct Cache Access capabilities. See Table 3\-8.

.SH INPUT EAX = 0AH: RETURNS ARCHITECTURAL PERFORMANCE MONITORING FEATURES
.PP
When CPUID executes with EAX set to 0AH, the processor returns
information about support for architectural performance monitoring
capabilities. Architectural performance monitoring is supported if the
version ID (see Table 3\-8) is greater than Pn 0. See Table 3\-8.

.PP
For each version of architectural performance monitoring capability,
software must enumerate this leaf to discover the programming facilities
and the architectural performance events available in the processor. The
details are described in Chapter 23, “Introduction to Virtual\-Machine
Extensions,” in the Intel® 64 and IA\-32 Architectures Software
Developer’s Manual, Volume 3C.

.SH INPUT EAX = 0BH: RETURNS EXTENDED TOPOLOGY INFORMATION
.PP
CPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends
first checking for the existence of Leaf 1FH before using leaf 0BH.

.PP
When CPUID executes with EAX set to 0BH, the processor returns
information about extended topology enumeration data. Software must
detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf
index supported by CPUID is \&gt;= 0BH, and (b) CPUID.0BH:EBX[15:0]
reports a non\-zero value. See Table 3\-8.

.SH INPUT EAX = 0DH: RETURNS PROCESSOR EXTENDED STATES ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 0DH and ECX = 0, the processor
returns information about the bit\-vector representation of all processor
state extensions that are supported in the processor and storage size
requirements of the XSAVE/XRSTOR area. See Table 3\-8.

.PP
When CPUID executes with EAX set to 0DH and ECX = n (n \&gt; 1, and is a
valid sub\-leaf index), the processor returns information about the size
and offset of each processor extended state save area within the
XSAVE/XRSTOR area. See Table 3\-8. Software can use the
forward\-extendable technique depicted below to query the valid
sub\-leaves and obtain size and offset information for each processor
extended state save area:

.PP
For i = 2 to 62 // sub\-leaf 1 is reserved IF (CPUID.(EAX=0DH,
ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64\-bit value of EDX:EAX
Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub\-leaf
i; FI;

.SH INPUT EAX = 0FH: RETURNS INTEL RESOURCE DIRECTOR TECHNOLOGY (INTEL RDT) MONITORING ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 0FH and ECX = 0, the processor
returns information about the bit\-vector representation of QoS
monitoring resource types that are supported in the processor and
maximum range of RMID values the processor can use to monitor of any
supported resource types. Each bit, starting from bit 1, corresponds to
a specific resource type if the bit is set. The bit position corresponds
to the sub\-leaf index (or ResID) that software must use to query QoS
monitoring capability available for that type. See Table 3\-8.

.PP
When CPUID executes with EAX set to 0FH and ECX = n (n \&gt;= 1, and is a
valid ResID), the processor returns information software can use to
program IA32\_PQR\_ASSOC, IA32\_QM\_EVTSEL MSRs before reading QoS data
from the IA32\_QM\_CTR MSR.

.SH INPUT EAX = 10H: RETURNS INTEL RESOURCE DIRECTOR TECHNOLOGY (INTEL RDT) ALLOCATION ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 10H and ECX = 0, the processor
returns information about the bit\-vector representation of QoS
Enforcement resource types that are supported in the processor. Each
bit, starting from bit 1, corresponds to a specific resource type if the
bit is set. The bit position corresponds to the sub\-leaf index (or
ResID) that software must use to query QoS enforcement capability
available for that type. See Table 3\-8.

.PP
When CPUID executes with EAX set to 10H and ECX = n (n \&gt;= 1, and is a
valid ResID), the processor returns information about available classes
of service and range of QoS mask MSRs that software can use to configure
each class of services using capability bit masks in the QoS Mask
registers, IA32\_resourceType\_Mask\_n.

.SH INPUT EAX = 12H: RETURNS INTEL SGX ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 12H and ECX = 0H, the processor
returns information about Intel SGX capabilities. See Table 3\-8.

.PP
When CPUID executes with EAX set to 12H and ECX = 1H, the processor
returns information about Intel SGX attributes. See Table 3\-8.

.PP
When CPUID executes with EAX set to 12H and ECX = n (n \&gt; 1), the
processor returns information about Intel SGX Enclave Page Cache. See
Table 3\-8.

.SH INPUT EAX = 14H: RETURNS INTEL PROCESSOR TRACE ENUMERATION INFORMATION
.PP
When CPUID executes with EAX set to 14H and ECX = 0H, the processor
returns information about Intel Processor Trace extensions. See Table
3\-8.

.PP
When CPUID executes with EAX set to 14H and ECX = n (n \&gt; 0 and less
than the number of non\-zero bits in CPUID.(EAX=14H, ECX= 0H).EAX), the
processor returns information about packet generation in Intel Processor
Trace. See Table 3\-8.

.SH INPUT EAX = 15H: RETURNS TIME STAMP COUNTER AND NOMINAL CORE CRYSTAL CLOCK INFORMATION
.PP
When CPUID executes with EAX set to 15H and ECX = 0H, the processor
returns information about Time Stamp Counter and Core Crystal Clock. See
Table 3\-8.

.SH INPUT EAX = 16H: RETURNS PROCESSOR FREQUENCY INFORMATION
.PP
When CPUID executes with EAX set to 16H, the processor returns
information about Processor Frequency Information. See Table 3\-8.

.SH INPUT EAX = 17H: RETURNS SYSTEM\-ON\-CHIP INFORMATION
.PP
When CPUID executes with EAX set to 17H, the processor returns
information about the System\-On\-Chip Vendor Attribute Enumeration. See
Table 3\-8.

.SH INPUT EAX = 18H: RETURNS DETERMINISTIC ADDRESS TRANSLATION PARAMETERS INFORMATION
.PP
When CPUID executes with EAX set to 18H, the processor returns
information about the Deterministic Address Translation Parameters. See
Table 3\-8.

.SH INPUT EAX = 1FH: RETURNS V2 EXTENDED TOPOLOGY INFORMATION
.PP
When CPUID executes with EAX set to 1FH, the processor returns
information about extended topology enumeration data. Software must
detect the presence of CPUID leaf 1FH by verifying (a) the highest leaf
index supported by CPUID is \&gt;= 1FH, and (b) CPUID.1FH:EBX[15:0]
reports a non\-zero value. See Table 3\-8.

.SH METHODS FOR RETURNING BRANDING INFORMATION
.PP
Use the following techniques to access branding information:

.PP
1\&. Processor brand string method.

.PP
2\&. Processor brand index; this method uses a software supplied brand
string table.

.PP
These two methods are discussed in the following sections. For methods
that are available in early processors, see Section: “Identification of
Earlier IA\-32 Processors” in Chapter 19 of the Intel® 64 and IA\-32
Architectures Software Developer’s Manual, Volume 1.

.SH THE PROCESSOR BRAND STRING METHOD
.PP
Figure 3\-9 describes the algorithm used for detection of the brand
string. Processor brand identification software should execute this
algorithm on all Intel 64 and IA\-32 processors.

.PP
This method (introduced with Pentium 4 processors) returns an ASCII
brand identification string and the Processor Base frequency of the
processor to the EAX, EBX, ECX, and EDX registers.

.PP
Input: EAX=0x80000000CPUIDProcessor BrandFalseIF (EAX \&
0x80000000)String NotSupportedCPUIDTrue≥FunctionExtendedSupportedEAX
Return Value =Max. Extended CPUIDFunction IndexTrueProcessor BrandIF
(EAX Return ValueString Supported≥ 0x80000004)

.PP
Figure 3\-9. Determination of Support for the Processor Brand String

.SH HOW BRAND STRINGS WORK
.PP
To use the brand string method, execute CPUID with EAX input of 8000002H
through 80000004H. For each input value, CPUID returns 16 ASCII
characters using EAX, EBX, ECX, and EDX. The returned string will be
NULL\-terminated.

.PP
Table 3\-13 shows the brand string that is returned by the first
processor in the Pentium 4 processor family.

.TS
allbox;
l l l 
l l l .
\fB\fCEAX Input Value\fR	\fB\fCReturn Values\fR	\fB\fCASCII Equivalent\fR
80000002H	T{
EAX = 20202020H EBX = 20202020H ECX = 20202020H EDX = 6E492020H
T}
	“” “” “” “nI ”
80000003H	T{
EAX = 286C6574H EBX = 50202952H ECX = 69746E65H EDX = 52286D75H
T}
	T{
“(let” “P )R” “itne” “R(mu”
T}
80000004H	T{
EAX = 20342029H EBX = 20555043H ECX = 30303531H EDX = 007A484DH
T}
	T{
“ 4 )” “ UPC” “0051” “
T}
\\
0zHM”
.TE

.PP
Table 3\-13. Processor Brand String Returned with Pentium 4 Processor

.SH EXTRACTING THE PROCESSOR FREQUENCY FROM BRAND STRINGS
.PP
Figure 3\-10 provides an algorithm which software can use to extract the
Processor Base frequency from the processor brand string.

.PP
Scan "Brand String" inReverse Byte Order"zHM", or Match"zHG", or
Substring"zHT"FalseIF Substring MatchedReport ErrorDetermine "Freq"
TrueIf "zHM"Multiplier = 1 x 106and "Multiplier"If "zHG"Multiplier = 1 x
109Determine "Multiplier"If "zHT"Multiplier = 1 x 1012Scan DigitsUntil
BlankReverse DigitsTo Decimal ValueIn Reverse OrderFrequency ="Freq" x
"Multiplier"Digits = "ZY.X"

.PP
Figure 3\-10. Algorithm for Extracting Processor Frequency

.SH THE PROCESSOR BRAND INDEX METHOD
.PP
The brand index method (introduced with Pentium® processors) provides an
entry point into a brand identification table that is maintained in
memory by system software and is accessible from system\- and user\-level
code. In this table, each brand index is associate with an ASCII brand
identification string that identifies the official Intel family and
model number of a processor.

.PP
When CPUID executes with EAX set to 1, the processor returns a brand
index to the low byte in EBX. Software can then use this index to locate
the brand identification string for the processor in the brand
identification table. The first entry (brand index 0) in this table is
reserved, allowing for backward compatibility with processors that do
not support the brand identification feature. Starting with processor
signature family ID = 0FH, model = 03H, brand index method is no longer
supported. Use brand string method instead.

.PP
Table 3\-14 shows brand indices that have identification strings
associated with them.

.TS
allbox;
l l 
l l .
\fB\fCBrand Index\fR	\fB\fCBrand String\fR
00H	T{
This processor does not support the brand identification feature
T}
01H	Intel(R) Celeron(R) processor1
02H	T{
Intel(R) Pentium(R) III processor1
T}
03H	T{
Intel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor
T}
04H	T{
Intel(R) Pentium(R) III processor
T}
06H	T{
Mobile Intel(R) Pentium(R) III processor\-M
T}
07H	T{
Mobile Intel(R) Celeron(R) processor1
T}
08H	T{
Intel(R) Pentium(R) 4 processor
T}
09H	T{
Intel(R) Pentium(R) 4 processor
T}
0AH	Intel(R) Celeron(R) processor1
0BH	T{
Intel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP
T}
0CH	Intel(R) Xeon(R) processor MP
0EH	T{
Mobile Intel(R) Pentium(R) 4 processor\-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor
T}
0FH	T{
Mobile Intel(R) Celeron(R) processor1
T}
11H	T{
Mobile Genuine Intel(R) processor
T}
12H	T{
Intel(R) Celeron(R) M processor
T}
13H	T{
Mobile Intel(R) Celeron(R) processor1
T}
14H	Intel(R) Celeron(R) processor
15H	T{
Mobile Genuine Intel(R) processor
T}
16H	T{
Intel(R) Pentium(R) M processor
T}
17H	T{
Mobile Intel(R) Celeron(R) processor1
T}
18H – 0FFH	RESERVED
.TE

.PP
Table 3\-14. Mapping of Brand Indices; and Intel 64 and IA\-32 Processor
Brand Strings

.PP
NOTES:

.PP
1\&. Indicates versions of these processors that were introduced after
the Pentium III

.SH IA\-32 ARCHITECTURE COMPATIBILITY
.PP
CPUID is not supported in early models of the Intel486 processor or in
any IA\-32 processor earlier than the Intel486 processor.

.SH OPERATION
.PP
.RS

.nf
IA32\_BIOS\_SIGN\_ID MSR ← Update with installed microcode revision number;
CASE (EAX) OF
    EAX = 0:
        EAX ← Highest basic function input value understood by CPUID;
        EBX ← Vendor identification string;
        EDX ← Vendor identification string;
        ECX ← Vendor identification string;
    BREAK;
    EAX = 1H:
        EAX[3:0] ← Stepping ID;
        EAX[7:4] ← Model;
        EAX[11:8] ← Family;
        EAX[13:12] ← Processor type;
        EAX[15:14] ← Reserved;
        EAX[19:16] ← Extended Model;
        EAX[27:20] ← Extended Family;
        EAX[31:28] ← Reserved;
        EBX[7:0] ← Brand Index; (* Reserved if the value is zero. *)
        EBX[15:8] ← CLFLUSH Line Size;
        EBX[16:23] ← Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)
        EBX[24:31] ← Initial APIC ID;
        ECX ← Feature flags; (* See Figure 3\-7. *)
        EDX ← Feature flags; (* See Figure 3\-8. *)
    BREAK;
    EAX = 2H:
        EAX ← Cache and TLB information;
        EBX ← Cache and TLB information;
        ECX ← Cache and TLB information;
        EDX ← Cache and TLB information;
    BREAK;
    EAX = 3H:
        EAX ← Reserved;
        EBX ← Reserved;
        ECX ← ProcessorSerialNumber[31:0];
        (* Pentium III processors only, otherwise reserved. *)
        EDX ← ProcessorSerialNumber[63:32];
        (* Pentium III processors only, otherwise reserved. *
    BREAK
    EAX = 4H:
        EAX ← Deterministic Cache Parameters Leaf; (* See Table 3\-8. *)
        EBX ← Deterministic Cache Parameters Leaf;
        ECX ← Deterministic Cache Parameters Leaf;
        EDX ← Deterministic Cache Parameters Leaf;
    BREAK;
    EAX = 5H:
        EAX ← MONITOR/MWAIT Leaf; (* See Table 3\-8. *)
        EBX ← MONITOR/MWAIT Leaf;
        ECX ← MONITOR/MWAIT Leaf;
        EDX ← MONITOR/MWAIT Leaf;
    BREAK;
    EAX = 6H:
        EAX ← Thermal and Power Management Leaf; (* See Table 3\-8. *)
        EBX ← Thermal and Power Management Leaf;
        ECX ← Thermal and Power Management Leaf;
        EDX ← Thermal and Power Management Leaf;
    BREAK;
    EAX = 7H:
        EAX ← Structured Extended Feature Flags Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Structured Extended Feature Flags Enumeration Leaf;
        ECX ← Structured Extended Feature Flags Enumeration Leaf;
        EDX ← Structured Extended Feature Flags Enumeration Leaf;
    BREAK;
    EAX = 8H:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Reserved = 0;
        EDX ← Reserved = 0;
    BREAK;
    EAX = 9H:
        EAX ← Direct Cache Access Information Leaf; (* See Table 3\-8. *)
        EBX ← Direct Cache Access Information Leaf;
        ECX ← Direct Cache Access Information Leaf;
        EDX ← Direct Cache Access Information Leaf;
    BREAK;
    EAX = AH:
        EAX ← Architectural Performance Monitoring Leaf; (* See Table 3\-8. *)
        EBX ← Architectural Performance Monitoring Leaf;
        ECX ← Architectural Performance Monitoring Leaf;
        EDX ← Architectural Performance Monitoring Leaf;
        BREAK
    EAX = BH:
        EAX ← Extended Topology Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Extended Topology Enumeration Leaf;
        ECX ← Extended Topology Enumeration Leaf;
        EDX ← Extended Topology Enumeration Leaf;
    BREAK;
    EAX = CH:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Reserved = 0;
        EDX ← Reserved = 0;
    BREAK;
    EAX = DH:
        EAX ← Processor Extended State Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Processor Extended State Enumeration Leaf;
        ECX ← Processor Extended State Enumeration Leaf;
        EDX ← Processor Extended State Enumeration Leaf;
    BREAK;
    EAX = EH:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Reserved = 0;
        EDX ← Reserved = 0;
    BREAK;
    EAX = FH:
        EAX ← Intel Resource Director Technology Monitoring Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Intel Resource Director Technology Monitoring Enumeration Leaf;
        ECX ← Intel Resource Director Technology Monitoring Enumeration Leaf;
        EDX ← Intel Resource Director Technology Monitoring Enumeration Leaf;
    BREAK;
    EAX = 10H:
        EAX ← Intel Resource Director Technology Allocation Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Intel Resource Director Technology Allocation Enumeration Leaf;
        ECX ← Intel Resource Director Technology Allocation Enumeration Leaf;
        EDX ← Intel Resource Director Technology Allocation Enumeration Leaf;
    BREAK;
        EAX = 12H:
        EAX ← Intel SGX Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Intel SGX Enumeration Leaf;
        ECX ← Intel SGX Enumeration Leaf;
        EDX ← Intel SGX Enumeration Leaf;
    BREAK;
    EAX = 14H:
        EAX ← Intel Processor Trace Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Intel Processor Trace Enumeration Leaf;
        ECX ← Intel Processor Trace Enumeration Leaf;
        EDX ← Intel Processor Trace Enumeration Leaf;
    BREAK;
    EAX = 15H:
        EAX ← Time Stamp Counter and Nominal Core Crystal Clock Information Leaf; (* See Table 3\-8. *)
        EBX ← Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
        ECX ← Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
        EDX ← Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
    BREAK;
    EAX = 16H:
        EAX ←
            Processor Frequency Information Enumeration Leaf; (* See Table 3\-8. *)
        EBX ←
            Processor Frequency Information Enumeration Leaf;
        ECX ←
            Processor Frequency Information Enumeration Leaf;
        EDX ←
            Processor Frequency Information Enumeration Leaf;
    BREAK;
    EAX = 17H:
        EAX ←
            System\-On\-Chip Vendor Attribute Enumeration Leaf; (* See Table 3\-8. *)
        EBX ←
            System\-On\-Chip Vendor Attribute Enumeration Leaf;
        ECX ←
            System\-On\-Chip Vendor Attribute Enumeration Leaf;
        EDX ←
            System\-On\-Chip Vendor Attribute Enumeration Leaf;
    BREAK;
        EAX = 18H:
        EAX ← Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← Deterministic Address Translation Parameters Enumeration Leaf;
        ECX ←Deterministic Address Translation Parameters Enumeration Leaf;
        EDX ← Deterministic Address Translation Parameters Enumeration Leaf;
    BREAK;
    EAX = 1FH:
        EAX ← V2 Extended Topology Enumeration Leaf; (* See Table 3\-8. *)
        EBX ← V2 Extended Topology Enumeration Leaf;
        ECX ← V2 Extended Topology Enumeration Leaf;
        EDX ← V2 Extended Topology Enumeration Leaf;
    BREAK;
    EAX = 80000000H:
        EAX ← Highest extended function input value understood by CPUID;
        EBX ← Reserved;
        ECX ← Reserved;
        EDX ← Reserved;
    BREAK;
    EAX = 80000001H:
        EAX ← Reserved;
        EBX ← Reserved;
        ECX ← Extended Feature Bits (* See Table 3\-8.*);
        EDX ← Extended Feature Bits (* See Table 3\-8. *);
    BREAK;
    EAX = 80000002H:
        EAX ← Processor Brand String;
        EBX ← Processor Brand String,
                continued;
        ECX ← Processor Brand String,
                continued;
        EDX ← Processor Brand String,
                continued;
    BREAK;
    EAX = 80000003H:
        EAX ← Processor Brand String,
                continued;
        EBX ← Processor Brand String,
                continued;
        ECX ← Processor Brand String,
                continued;
        EDX ← Processor Brand String,
                continued;
    BREAK;
    EAX = 80000004H:
        EAX ← Processor Brand String,
                continued;
        EBX ← Processor Brand String,
                continued;
        ECX ← Processor Brand String,
                continued;
        EDX ← Processor Brand String,
                continued;
    BREAK;
    EAX = 80000005H:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Reserved = 0;
        EDX ← Reserved = 0;
    BREAK;
    EAX = 80000006H:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Cache information;
        EDX ← Reserved = 0;
    BREAK;
    EAX = 80000007H:
        EAX ← Reserved = 0;
        EBX ← Reserved = 0;
        ECX ← Reserved = 0;
        EDX ← Reserved = Misc Feature Flags;
    BREAK;
    EAX = 80000008H:
        EAX ← Reserved = Physical Address Size Information;
        EBX ← Reserved = Virtual Address Size Information;
        ECX ← Reserved = 0;
        EDX ← Reserved = 0;
    BREAK;
    EAX >= 40000000H and EAX <= 4FFFFFFFH:
    DEFAULT: (* EAX = Value outside of recognized range for CPUID. *)
        (* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)
        EAX ← Reserved; (* Information returned for highest basic information leaf. *)
        EBX ← Reserved; (* Information returned for highest basic information leaf. *)
        ECX ← Reserved; (* Information returned for highest basic information leaf. *)
        EDX ← Reserved; (* Information returned for highest basic information leaf. *)
    BREAK;
ESAC;

.fi
.RE

.SH FLAGS AFFECTED
.PP
None.

.SH EXCEPTIONS (ALL OPERATING MODES)
.PP
#UD If the LOCK prefix is used.

.PP
In earlier IA\-32 processors that do not support the CPUID instruction,
execution of the instruction results in an invalid opcode (#UD)
exception being generated.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
